#!/bin/bash
#
# Copyright (c) 2026 Red Hat, Inc.
# This program and the accompanying materials are made
# available under the terms of the Eclipse Public License 2.0
# which is available at https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Contributors:
#   Red Hat, Inc. - initial API and implementation
#

# Deploy Eclipse Che with IPv6 support on OpenShift
#
# This script deploys Eclipse Che on OpenShift clusters with IPv6 support
# using the PR-1442 dashboard image that includes IPv6 URL validation.
#
# Deployment Methods:
# 1. chectl (default): Uses chectl server:deploy with operator installer
# 2. Manual OLM (--manual-olm): Deploys via OLM directly, bypassing chectl's
#    hardcoded 120-second subscription timeout (recommended for IPv6-only clusters)
#
# Prerequisites:
# - oc CLI configured and connected to an OpenShift cluster
# - chectl installed (only if not using --manual-olm)
# - OpenShift cluster with IPv6 networking support
#   (launched via cluster bot: "launch 4.20.2 metal,ipv6")
#
# Usage:
#   ./deploy-che-ipv6-chectl.sh [options]
#
# Options:
#   --kubeconfig <file>          Path to kubeconfig file (uses proxy-url from kubeconfig)
#   --namespace <namespace>      Che namespace (default: eclipse-che for upstream, openshift-workspaces for CRW)
#   --dashboard-image <image>    Dashboard image (default: quay.io/eclipse/che-dashboard:pr-1442)
#   --che-operator-image <image> Che operator image (default: quay.io/eclipse/che-operator:next)
#   --crw                        Deploy CodeReady Workspaces (Red Hat downstream) instead of upstream Eclipse Che
#   --install-chectl             Install chectl automatically if missing (best-effort)
#   --manual-olm                 Deploy Eclipse Che manually via OLM (bypasses chectl, avoids 120s timeout)
#   --olm-timeout <seconds>      Timeout for OLM subscription readiness (default: 600, only with --manual-olm)
#   --skip-ipv6-check           Skip IPv6 cluster verification
#   --skip-mirror               Skip image mirroring (use if images already mirrored)
#   --mirror-mode <minimal|full> Mirroring mode for IPv6-only clusters (default: full)
#   --quay-creds <user:pass>     Optional Quay credentials (passed to mirror script as --quay-creds)
#   --prefetch-images            Predownload base images to local cache before touching the cluster
#   --cache-dir <path>           Cache directory for prefetch + mirror reuse (default: ~/.cache/che-ipv6-mirror/)
#   --local-registry <registry>  Local registry for image mirroring (auto-detected if not specified)
#   --help                       Show this help message
#
# Generated by Claude Sonnet 4.5
#
# Generated by GPT-5.2

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default configuration
DEPLOY_CRW=false
NAMESPACE=""
DASHBOARD_IMAGE=""
CHE_OPERATOR_IMAGE=""
SKIP_IPV6_CHECK=false
SKIP_MIRROR=false
LOCAL_REGISTRY=""
KUBECONFIG_FILE=""
INSTALL_CHECTL=false
MANUAL_OLM=false
OLM_TIMEOUT=600
MIRROR_MODE="full"
QUAY_CREDS="${QUAY_CREDS:-}"
OPENSHIFT_REGISTRY_HOST="image-registry.openshift-image-registry.svc:5000"
# Prefetch/cache options
# Generated by GPT-5.2
PREFETCH_IMAGES=false
CACHE_DIR="${CACHE_DIR:-${HOME}/.cache/che-ipv6-mirror}"

extract_proxy_url_from_kubeconfig() {
    # Reads the first "proxy-url:" entry from the kubeconfig (cluster-bot kubeconfigs often include it).
    # Returns empty string if not found.
    local kc="${1:-}"
    if [ -n "${kc}" ] && [ -f "${kc}" ]; then
        grep -m1 'proxy-url:' "${kc}" 2>/dev/null | awk '{print $2}' || true
    else
        grep -m1 'proxy-url:' "${KUBECONFIG:-}" 2>/dev/null | awk '{print $2}' || true
    fi
}

is_host_resolvable() {
    # Returns 0 if host resolves locally, 1 otherwise.
    local host="${1:-}"
    [ -z "${host}" ] && return 1
    python3 - <<'PY' "${host}" >/dev/null 2>&1
import socket, sys
host=sys.argv[1]
socket.getaddrinfo(host, 443)
PY
}

prepare_chectl_kubeconfig() {
    # chectl (Node.js) can fail with ENOTFOUND for cluster-bot API hostnames when local DNS cannot resolve them.
    # If the API host isn't resolvable locally, run chectl through a local `oc proxy` and a temporary kubeconfig.
    #
    # Sets:
    # - CHECTL_KUBECONFIG: kubeconfig path to use for chectl
    # - CHECTL_OC_PROXY_PID: background oc proxy pid (if started)
    # - CHECTL_OC_PROXY_PORT: local oc proxy port (if started)
    CHECTL_KUBECONFIG="${KUBECONFIG:-}"
    CHECTL_OC_PROXY_PID=""
    CHECTL_OC_PROXY_PORT=""

    local api_server
    api_server="$(oc whoami --show-server 2>/dev/null || true)"
    if [ -z "${api_server}" ]; then
        return 0
    fi

    local api_host
    api_host="$(echo "${api_server}" | sed -E 's|^https?://||' | cut -d/ -f1 | cut -d: -f1)"
    if [ -z "${api_host}" ]; then
        return 0
    fi

    if is_host_resolvable "${api_host}"; then
        return 0
    fi

    echo -e "${YELLOW}⚠ Local DNS cannot resolve API host: ${api_host}${NC}"
    echo -e "${YELLOW}  Using local oc proxy for chectl to avoid ENOTFOUND${NC}"

    local port="8001"
    local tmp_kc="/tmp/chectl-oc-proxy.kubeconfig"

    # Start oc proxy in background (best-effort). If it fails, chectl will likely fail too.
    oc proxy --port="${port}" --accept-hosts='^.*$' >/dev/null 2>&1 &
    CHECTL_OC_PROXY_PID="$!"
    CHECTL_OC_PROXY_PORT="${port}"

    # Ensure proxy is stopped on exit
    trap 'if [ -n "${CHECTL_OC_PROXY_PID}" ]; then kill "${CHECTL_OC_PROXY_PID}" >/dev/null 2>&1 || true; fi' EXIT

    # Create a kubeconfig that points to the local proxy, and remove proxy-url entries.
    python3 - <<'PY' "${KUBECONFIG:-}" "${tmp_kc}" "${port}"
import pathlib, re, sys
src = pathlib.Path(sys.argv[1])
dst = pathlib.Path(sys.argv[2])
port = sys.argv[3]
text = src.read_text(errors="ignore")
text = "\n".join([l for l in text.splitlines() if "proxy-url:" not in l]) + "\n"
text = re.sub(r"^(\s*server:\s*).+$", r"\1http://127.0.0.1:%s" % port, text, flags=re.M)
dst.write_text(text)
print(dst)
PY

    CHECTL_KUBECONFIG="${tmp_kc}"
}

# Generated by GPT-5.2
wait_for_oc_api() {
    # Wait until oc can reach the API server (cluster-bot proxy-url can be temporarily unavailable).
    local tries="${1:-40}"
    local delay_seconds="${2:-15}"
    local i
    for ((i=1; i<=tries; i++)); do
        if oc whoami >/dev/null 2>&1; then
            return 0
        fi
        echo "  Waiting for OpenShift API connectivity... (${i}/${tries})"
        sleep "${delay_seconds}"
    done
    return 1
}

# Generated by GPT-5.2
wait_for_local_oc_proxy() {
    # Wait for the local oc proxy endpoint to be usable (oc proxy returns 500 when upstream is unreachable).
    local port="${1:-8001}"
    local tries="${2:-40}"
    local delay_seconds="${3:-2}"
    local i
    for ((i=1; i<=tries; i++)); do
        if curl -fsS --max-time 2 "http://127.0.0.1:${port}/api" >/dev/null 2>&1; then
            return 0
        fi
        sleep "${delay_seconds}"
    done
    return 1
}

deploy_che_manual_olm() {
    # Deploy Eclipse Che or CodeReady Workspaces manually via OLM without chectl
    # This bypasses chectl's hardcoded 120-second subscription timeout

    echo -e "${YELLOW}Step 4: Deploying ${PRODUCT_NAME} manually via OLM${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"
    echo ""

    # Step 4a: Create namespace
    echo -e "${BLUE}[1/6] Creating namespace${NC}"
    if oc get namespace "${NAMESPACE}" &>/dev/null; then
        echo -e "${GREEN}✓ Namespace '${NAMESPACE}' already exists${NC}"
    else
        oc create namespace "${NAMESPACE}"
        echo -e "${GREEN}✓ Namespace '${NAMESPACE}' created${NC}"
    fi
    echo ""

    # Step 4b: Verify CatalogSources
    echo -e "${BLUE}[2/6] Verifying CatalogSources${NC}"
    local catalog_timeout=120

    # Wait for main operator catalog
    echo "  Waiting for ${CATALOG_SOURCE_NAME} CatalogSource..."
    for ((i=1; i<=$catalog_timeout; i++)); do
        if oc get catalogsource ${CATALOG_SOURCE_NAME} -n ${CATALOG_SOURCE_NAMESPACE} &>/dev/null; then
            local catalog_state=$(oc get catalogsource ${CATALOG_SOURCE_NAME} -n ${CATALOG_SOURCE_NAMESPACE} -o jsonpath='{.status.connectionState.lastObservedState}' 2>/dev/null || echo "")
            if [ "${catalog_state}" == "READY" ]; then
                echo -e "${GREEN}✓ ${CATALOG_SOURCE_NAME} CatalogSource is READY${NC}"
                break
            fi
        fi
        if [ $i -eq $catalog_timeout ]; then
            echo -e "${RED}✗ Timeout waiting for ${CATALOG_SOURCE_NAME} CatalogSource${NC}"
            echo "  Check if catalog exists: oc get catalogsource -n ${CATALOG_SOURCE_NAMESPACE}"
            exit 1
        fi
        sleep 1
    done

    # For upstream Che, also wait for devworkspace-operator catalog
    if [ "${DEPLOY_CRW}" != "true" ]; then
        echo "  Waiting for devworkspace-operator CatalogSource..."
        for ((i=1; i<=$catalog_timeout; i++)); do
            if oc get catalogsource devworkspace-operator -n openshift-marketplace &>/dev/null 2>&1; then
                local catalog_state=$(oc get catalogsource devworkspace-operator -n openshift-marketplace -o jsonpath='{.status.connectionState.lastObservedState}' 2>/dev/null || echo "")
                if [ "${catalog_state}" == "READY" ]; then
                    echo -e "${GREEN}✓ devworkspace-operator CatalogSource is READY${NC}"
                    break
                fi
            fi
            if [ $i -eq $catalog_timeout ]; then
                echo -e "${YELLOW}⚠ devworkspace-operator CatalogSource not ready, continuing anyway${NC}"
                break
            fi
            sleep 1
        done
    fi
    echo ""

    # Step 4c: Create DevWorkspace subscription
    echo -e "${BLUE}[3/6] Creating DevWorkspace Operator subscription${NC}"
    cat <<EOF | oc apply -f -
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: devworkspace-operator
  namespace: ${NAMESPACE}
spec:
  channel: next
  installPlanApproval: Automatic
  name: devworkspace-operator
  source: devworkspace-operator
  sourceNamespace: openshift-marketplace
EOF
    echo -e "${GREEN}✓ DevWorkspace subscription created${NC}"
    echo ""

    # Step 4d: Wait for DevWorkspace CSV
    echo -e "${BLUE}[4/6] Waiting for DevWorkspace Operator CSV (timeout: ${OLM_TIMEOUT}s)${NC}"
    local csv_found=false
    for ((i=1; i<=$OLM_TIMEOUT; i++)); do
        local csv=$(oc get subscription devworkspace-operator -n ${NAMESPACE} -o jsonpath='{.status.installedCSV}' 2>/dev/null || echo "")
        if [ -n "${csv}" ]; then
            echo "  Found CSV: ${csv}"
            local csv_phase=$(oc get csv "${csv}" -n ${NAMESPACE} -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
            echo "  CSV Phase: ${csv_phase}"
            if [ "${csv_phase}" == "Succeeded" ]; then
                echo -e "${GREEN}✓ DevWorkspace Operator installed successfully${NC}"
                csv_found=true
                break
            fi
        fi
        if [ $((i % 10)) -eq 0 ]; then
            echo "  Waiting for DevWorkspace CSV... (${i}/${OLM_TIMEOUT}s)"
        fi
        sleep 1
    done

    if [ "${csv_found}" != "true" ]; then
        echo -e "${RED}✗ Timeout waiting for DevWorkspace CSV to be ready${NC}"
        echo "  Current subscription status:"
        oc get subscription devworkspace-operator -n ${NAMESPACE} -o yaml 2>/dev/null || true
        exit 1
    fi
    echo ""

    # Step 4e: Create operator subscription
    echo -e "${BLUE}[5/6] Creating ${PRODUCT_NAME} subscription${NC}"

    # Determine channel based on product
    local channel="next"
    if [ "${DEPLOY_CRW}" = "true" ]; then
        channel="stable"
    fi

    cat <<EOF | oc apply -f -
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: ${OPERATOR_NAME}
  namespace: ${NAMESPACE}
spec:
  channel: ${channel}
  installPlanApproval: Automatic
  name: ${OPERATOR_NAME}
  source: ${CATALOG_SOURCE_NAME}
  sourceNamespace: ${CATALOG_SOURCE_NAMESPACE}
EOF
    echo -e "${GREEN}✓ ${PRODUCT_NAME} subscription created${NC}"
    echo ""

    # Step 4f: Wait for operator CSV
    echo -e "${BLUE}[6/6] Waiting for ${PRODUCT_NAME} CSV (timeout: ${OLM_TIMEOUT}s)${NC}"
    csv_found=false
    for ((i=1; i<=$OLM_TIMEOUT; i++)); do
        local csv=$(oc get subscription ${OPERATOR_NAME} -n ${NAMESPACE} -o jsonpath='{.status.installedCSV}' 2>/dev/null || echo "")
        if [ -n "${csv}" ]; then
            echo "  Found CSV: ${csv}"
            local csv_phase=$(oc get csv "${csv}" -n ${NAMESPACE} -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
            echo "  CSV Phase: ${csv_phase}"
            if [ "${csv_phase}" == "Succeeded" ]; then
                echo -e "${GREEN}✓ ${PRODUCT_NAME} Operator installed successfully${NC}"
                csv_found=true
                break
            fi
        fi
        if [ $((i % 10)) -eq 0 ]; then
            echo "  Waiting for ${PRODUCT_NAME} CSV... (${i}/${OLM_TIMEOUT}s)"
        fi
        sleep 1
    done

    if [ "${csv_found}" != "true" ]; then
        echo -e "${RED}✗ Timeout waiting for ${PRODUCT_NAME} CSV to be ready${NC}"
        echo "  Current subscription status:"
        oc get subscription ${OPERATOR_NAME} -n ${NAMESPACE} -o yaml 2>/dev/null || true
        echo ""
        echo "  Checking for InstallPlan:"
        oc get installplan -n ${NAMESPACE} 2>/dev/null || true
        exit 1
    fi
    echo ""

    # Step 4g: Create CheCluster
    echo -e "${YELLOW}Creating CheCluster with custom dashboard...${NC}"
    cat <<EOF | oc apply -f -
apiVersion: org.eclipse.che/v2
kind: CheCluster
metadata:
  name: ${OPERATOR_NAME}
  namespace: ${NAMESPACE}
spec:
  components:
    dashboard:
      deployment:
        containers:
        - image: ${DASHBOARD_IMAGE}
          imagePullPolicy: Always
          name: che-dashboard
  devEnvironments:
    startTimeoutSeconds: 600
EOF
    echo -e "${GREEN}✓ CheCluster created${NC}"
    echo ""
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --kubeconfig)
            KUBECONFIG_FILE="$2"
            shift 2
            ;;
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --dashboard-image)
            DASHBOARD_IMAGE="$2"
            shift 2
            ;;
        --che-operator-image)
            CHE_OPERATOR_IMAGE="$2"
            shift 2
            ;;
        --crw)
            DEPLOY_CRW=true
            shift
            ;;
        --install-chectl)
            INSTALL_CHECTL=true
            shift
            ;;
        --manual-olm)
            MANUAL_OLM=true
            shift
            ;;
        --olm-timeout)
            OLM_TIMEOUT="$2"
            shift 2
            ;;
        --skip-ipv6-check)
            SKIP_IPV6_CHECK=true
            shift
            ;;
        --skip-mirror)
            SKIP_MIRROR=true
            shift
            ;;
        --mirror-mode)
            MIRROR_MODE="$2"
            shift 2
            ;;
        --quay-creds)
            QUAY_CREDS="$2"
            shift 2
            ;;
        --prefetch-images)
            PREFETCH_IMAGES=true
            shift
            ;;
        --cache-dir)
            CACHE_DIR="$2"
            shift 2
            ;;
        --local-registry)
            LOCAL_REGISTRY="$2"
            shift 2
            ;;
        --help)
            grep '^#' "$0" | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Set defaults based on product (CRW vs upstream Che)
if [ "${DEPLOY_CRW}" = "true" ]; then
    # CodeReady Workspaces (Red Hat downstream)
    NAMESPACE="${NAMESPACE:-openshift-workspaces}"
    DASHBOARD_IMAGE="${DASHBOARD_IMAGE:-registry.redhat.io/codeready-workspaces/crw-2-rhel8-dashboard:latest}"
    CHE_OPERATOR_IMAGE="${CHE_OPERATOR_IMAGE:-registry.redhat.io/codeready-workspaces/crw-2-rhel8-operator:latest}"
    PRODUCT_NAME="CodeReady Workspaces"
    OPERATOR_NAME="codeready-workspaces"
    CATALOG_SOURCE_NAME="redhat-operators"
    CATALOG_SOURCE_NAMESPACE="openshift-marketplace"
else
    # Upstream Eclipse Che
    NAMESPACE="${NAMESPACE:-${CHE_NAMESPACE:-eclipse-che}}"
    DASHBOARD_IMAGE="${DASHBOARD_IMAGE:-quay.io/eclipse/che-dashboard:pr-1442}"
    CHE_OPERATOR_IMAGE="${CHE_OPERATOR_IMAGE:-quay.io/eclipse/che-operator:next}"
    PRODUCT_NAME="Eclipse Che"
    OPERATOR_NAME="eclipse-che"
    CATALOG_SOURCE_NAME="eclipse-che"
    CATALOG_SOURCE_NAMESPACE="openshift-marketplace"
fi

if [ "${MIRROR_MODE}" != "minimal" ] && [ "${MIRROR_MODE}" != "full" ]; then
    echo -e "${RED}Error: Invalid --mirror-mode '${MIRROR_MODE}'. Expected 'minimal' or 'full'.${NC}"
    exit 1
fi

# Optional prefetch before cluster access (best-effort)
# Generated by GPT-5.2
if [ "${PREFETCH_IMAGES}" = "true" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    MIRROR_SCRIPT="${SCRIPT_DIR}/mirror-images-to-registry.sh"
    echo -e "${YELLOW}Prefetching base images to cache before cluster deploy...${NC}"
    PREFETCH_ARGS=( --mode "${MIRROR_MODE}" --dashboard-image "${DASHBOARD_IMAGE}" --prefetch-only --cache-dir "${CACHE_DIR}" )
    if [ -n "${QUAY_CREDS}" ]; then
        PREFETCH_ARGS+=( --quay-creds "${QUAY_CREDS}" )
    fi
    bash "${MIRROR_SCRIPT}" "${PREFETCH_ARGS[@]}"
    echo ""
fi

# Set KUBECONFIG if provided
if [ -n "$KUBECONFIG_FILE" ]; then
    if [ ! -f "$KUBECONFIG_FILE" ]; then
        echo -e "${RED}Error: Kubeconfig file not found: $KUBECONFIG_FILE${NC}"
        exit 1
    fi
    export KUBECONFIG="$KUBECONFIG_FILE"
    echo -e "${GREEN}✓ Using kubeconfig: $KUBECONFIG_FILE${NC}"
    echo ""
fi

echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
if [ "${DEPLOY_CRW}" = "true" ]; then
    echo -e "${BLUE}║  Deploy CodeReady Workspaces with IPv6 on OpenShift       ║${NC}"
else
    echo -e "${BLUE}║  Deploy Eclipse Che with IPv6 Support on OpenShift        ║${NC}"
fi
echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${YELLOW}Configuration:${NC}"
echo "  Product:          ${PRODUCT_NAME}"
echo "  Platform:         OpenShift"
echo "  Deployment mode:  $([ "${MANUAL_OLM}" = "true" ] && echo "Manual OLM (timeout: ${OLM_TIMEOUT}s)" || echo "chectl")"
echo "  Namespace:        ${NAMESPACE}"
echo "  Dashboard image:  ${DASHBOARD_IMAGE}"
echo "  Operator image:   ${CHE_OPERATOR_IMAGE}"
echo ""

# Check prerequisites
echo -e "${YELLOW}Step 1: Checking prerequisites${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# Check oc CLI
if ! command -v oc &> /dev/null; then
    echo -e "${RED}Error: oc command not found${NC}"
    echo "Please install oc CLI: https://mirror.openshift.com/pub/openshift-v4/clients/ocp/"
    exit 1
fi
echo -e "${GREEN}✓ oc CLI found: $(oc version --client | head -1)${NC}"

# Check chectl (skip if using manual OLM)
if [ "${MANUAL_OLM}" = "false" ]; then
    if ! command -v chectl &> /dev/null; then
        if [ "${INSTALL_CHECTL}" = "true" ]; then
            echo -e "${YELLOW}chectl not found. Installing chectl...${NC}"
            if ! command -v curl &> /dev/null; then
                echo -e "${RED}Error: curl not found; cannot auto-install chectl.${NC}"
                exit 1
            fi
            # Generated by GPT-5.2
            bash -c "bash <(curl -fsSL https://che-incubator.github.io/chectl/install.sh)" || {
                echo -e "${RED}Error: chectl installation failed.${NC}"
                exit 1
            }
        else
            echo -e "${RED}Error: chectl not found${NC}"
            echo ""
            echo "Install chectl (or re-run with --install-chectl or --manual-olm):"
            echo "  # Using installer script"
            echo "  bash <(curl -sL https://che-incubator.github.io/chectl/install.sh)"
            echo ""
            echo "  # Or using npm"
            echo "  npm install -g chectl"
            echo ""
            echo "  # Or deploy without chectl"
            echo "  ./deploy-che-ipv6-chectl.sh --manual-olm ..."
            exit 1
        fi
    fi
    echo -e "${GREEN}✓ chectl found: $(chectl version)${NC}"
else
    echo -e "${YELLOW}⊙ Using manual OLM deployment (chectl not required)${NC}"
fi

# Check cluster connectivity
if ! oc whoami &> /dev/null; then
    echo -e "${RED}Error: Not logged into OpenShift cluster${NC}"
    echo ""
    echo "Please login to your cluster:"
    echo "  # If using cluster bot, set kubeconfig:"
    echo "  export KUBECONFIG=/path/to/cluster-bot-kubeconfig"
    echo ""
    echo "  # Verify connection:"
    echo "  oc whoami"
    echo "  oc get nodes"
    exit 1
fi
echo -e "${GREEN}✓ Logged into OpenShift as $(oc whoami)${NC}"

CLUSTER_VERSION=$(oc version | grep "Server Version" | awk '{print $3}' || echo "Unknown")
echo "  Cluster version: ${CLUSTER_VERSION}"
echo ""

# Step 2: Check IPv6 support
echo -e "${YELLOW}Step 2: Checking cluster IPv6 support${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# Determine service networks (IPv4 / IPv6)
SERVICE_NETS_RAW="$(oc get network.config.openshift.io cluster -o jsonpath='{.status.serviceNetwork[*]}' 2>/dev/null || echo "")"
IPV6_SERVICE_NET="$(echo "${SERVICE_NETS_RAW}" | tr ' ' '\n' | grep ':' | head -1 || true)"
IPV4_SERVICE_NET="$(echo "${SERVICE_NETS_RAW}" | tr ' ' '\n' | grep '\.' | head -1 || true)"

if [ -n "$IPV6_SERVICE_NET" ]; then
    echo -e "${GREEN}✓ Cluster has IPv6 service network: $IPV6_SERVICE_NET${NC}"
    IPV6_ENABLED=true
else
    echo -e "${YELLOW}⚠ No IPv6 service network detected (IPv4-only cluster)${NC}"
    IPV6_ENABLED=false

    if [ "$SKIP_IPV6_CHECK" == "false" ]; then
        echo ""
        echo -e "${YELLOW}This cluster appears to be IPv4-only.${NC}"
        echo "  ✅ IPv6 URL validation will still work"
        echo "  ✅ Backend will bind to :: (dual-stack ready)"
        echo "  ❌ Cannot test actual IPv6 connectivity"
        echo ""
        echo "For dual-stack IPv6 testing, launch cluster with cluster bot:"
        echo "  launch 4.20.2 metal,ipv6"
        echo ""
        read -p "Continue deployment anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Deployment cancelled${NC}"
            exit 0
        fi
    fi
fi

# Check pod network
IPV6_POD_NET="$(oc get network.config.openshift.io cluster -o jsonpath='{.status.clusterNetwork[*].cidr}' 2>/dev/null | tr ' ' '\n' | grep ':' | head -1 || true)"
if [ -n "$IPV6_POD_NET" ]; then
    echo -e "${GREEN}✓ Cluster has IPv6 pod network: $IPV6_POD_NET${NC}"
fi

# Check IP family policy
DUAL_STACK=$(oc get svc -A -o jsonpath='{.items[*].spec.ipFamilyPolicy}' 2>/dev/null | grep -i dual || echo "")
if [ -n "$DUAL_STACK" ]; then
    echo -e "${GREEN}✓ Cluster supports dual-stack services${NC}"
fi

echo ""

# Step 3: Check if image mirroring is needed
echo -e "${YELLOW}Step 3: Checking image mirroring requirements${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

if [ "$SKIP_MIRROR" == "true" ]; then
    echo -e "${YELLOW}⚠ Image mirroring skipped (--skip-mirror flag)${NC}"
    echo ""
else
    # Determine if this is an IPv6-only cluster. If there is no IPv4 service CIDR, treat as IPv6-only.
    if [ -z "${IPV4_SERVICE_NET}" ]; then
        echo -e "${YELLOW}⚠ IPv6-only cluster detected - image mirroring required${NC}"
        echo "  Public container registries don't support IPv6"
        if [ -n "${LOCAL_REGISTRY}" ]; then
            echo "  Using provided registry: ${LOCAL_REGISTRY}"
        else
            echo "  Using OpenShift internal registry mirror: ${OPENSHIFT_REGISTRY_HOST}"
        fi
        echo ""

        # Check if mirror script exists
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        MIRROR_SCRIPT="${SCRIPT_DIR}/mirror-images-to-registry.sh"

        if [ ! -f "$MIRROR_SCRIPT" ]; then
            echo -e "${RED}Error: Mirror script not found: ${MIRROR_SCRIPT}${NC}"
            echo "Please ensure mirror-images-to-registry.sh is in the same directory"
            exit 1
        fi

        echo -e "${YELLOW}Running image mirroring script...${NC}"
        echo "This will take 15-30 minutes to mirror all images"
        echo ""

        # Run the mirror script
        MIRROR_ARGS=( --namespace "${NAMESPACE}" --dashboard-image "${DASHBOARD_IMAGE}" --mode "${MIRROR_MODE}" )
        if [ -n "${KUBECONFIG_FILE}" ]; then
            MIRROR_ARGS+=( --kubeconfig "${KUBECONFIG_FILE}" )
        fi
        MIRROR_ARGS+=( --cache-dir "${CACHE_DIR}" )
        if [ -n "${LOCAL_REGISTRY}" ]; then
            MIRROR_ARGS+=( --registry "${LOCAL_REGISTRY}" )
        fi
        if [ -n "${QUAY_CREDS}" ]; then
            MIRROR_ARGS+=( --quay-creds "${QUAY_CREDS}" )
        fi

        bash "$MIRROR_SCRIPT" "${MIRROR_ARGS[@]}"

        echo ""
        echo -e "${GREEN}✓ Image mirroring completed${NC}"
        echo -e "${YELLOW}⚠ Nodes may reboot to apply new image policy${NC}"
        echo "  This may take 10-15 minutes"
        echo ""

        # Wait for nodes to be ready after MachineConfigPool update
        echo -e "${YELLOW}Waiting for all nodes to be Ready...${NC}"
        for i in {1..60}; do
                # With pipefail enabled, `grep -v` returning 1 (no matches) would break `|| echo ...`
                # and result in multi-line output like "0\n1". Count not-ready nodes safely instead.
                NOT_READY=$(oc get nodes --no-headers 2>/dev/null | grep -vc " Ready " || true)
            if [ "$NOT_READY" -eq 0 ]; then
                echo -e "${GREEN}✓ All nodes are Ready${NC}"
                break
            fi
            echo "  Waiting for nodes to be Ready... ($i/60) - ${NOT_READY} nodes not ready yet"
            sleep 15
        done

        # Verify MachineConfigPools are updated
        echo -e "${YELLOW}Verifying MachineConfigPool status...${NC}"
        oc get mcp 2>/dev/null || true
        echo ""

    else
        echo -e "${GREEN}✓ Cluster has IPv4 service network - direct image pull available${NC}"
        echo "  Image mirroring not required"
        echo ""
    fi
fi

# Step 4: Deploy Eclipse Che
if [ "${MANUAL_OLM}" = "true" ]; then
    # Use manual OLM deployment (bypasses chectl timeout issues)
    deploy_che_manual_olm
else
    # Use chectl deployment
    echo -e "${YELLOW}Step 4: Deploying Eclipse Che with chectl${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

    echo -e "${YELLOW}Running chectl server:deploy...${NC}"
    echo "This may take 5-10 minutes..."
    echo ""
fi

# Skip chectl-specific logic if using manual OLM
if [ "${MANUAL_OLM}" = "false" ]; then

# Ensure API is reachable before invoking chectl (avoid false failures when proxy-url is down)
if ! wait_for_oc_api 40 15; then
    echo -e "${RED}Error: OpenShift API is not reachable (kubeconfig proxy-url may be timing out).${NC}"
    echo -e "${RED}Please retry when the cluster-bot proxy becomes available again.${NC}"
    exit 1
fi

# Prepare chectl networking (proxy-url + optional local oc proxy kubeconfig)
prepare_chectl_kubeconfig
if [ -n "${CHECTL_OC_PROXY_PID}" ]; then
    if ! wait_for_local_oc_proxy "${CHECTL_OC_PROXY_PORT:-8001}" 80 1; then
        echo -e "${RED}Error: local oc proxy is not ready (cannot reach API).${NC}"
        exit 1
    fi
fi

PROXY_URL="$(extract_proxy_url_from_kubeconfig "${KUBECONFIG_FILE}")"
if [ -n "${PROXY_URL}" ]; then
    echo -e "${YELLOW}Using kubeconfig proxy for chectl: ${PROXY_URL}${NC}"
fi

# Ensure localhost bypasses proxy (critical when using oc proxy at 127.0.0.1)
# Generated by GPT-5.2
CHECTL_NO_PROXY="${NO_PROXY:-}"
if [ -n "${CHECTL_NO_PROXY}" ]; then
    CHECTL_NO_PROXY="${CHECTL_NO_PROXY},127.0.0.1,localhost,::1"
else
    CHECTL_NO_PROXY="127.0.0.1,localhost,::1"
fi

set +e
KUBECONFIG="${CHECTL_KUBECONFIG}" HTTPS_PROXY="${PROXY_URL:-}" HTTP_PROXY="${PROXY_URL:-}" NO_PROXY="${CHECTL_NO_PROXY}" chectl server:deploy \
    --platform openshift \
    --installer operator \
    --batch \
    --telemetry off \
    --chenamespace "${NAMESPACE}" \
    --che-operator-image "${CHE_OPERATOR_IMAGE}"
CHECTL_RC=$?
set -e

if [ "${CHECTL_RC}" -ne 0 ]; then
    echo ""
    echo -e "${YELLOW}⚠ chectl deploy failed (exit ${CHECTL_RC}).${NC}"
    if ! oc whoami >/dev/null 2>&1; then
        echo -e "${YELLOW}  Cluster API is currently unreachable (proxy-url timeout). Waiting and retrying chectl once...${NC}"
        if ! wait_for_oc_api 40 15; then
            echo -e "${RED}Error: OpenShift API still unreachable; cannot continue deployment.${NC}"
            exit 1
        fi
        echo -e "${YELLOW}Retrying chectl server:deploy...${NC}"
        set +e
        KUBECONFIG="${CHECTL_KUBECONFIG}" HTTPS_PROXY="${PROXY_URL:-}" HTTP_PROXY="${PROXY_URL:-}" NO_PROXY="${CHECTL_NO_PROXY}" chectl server:deploy \
            --platform openshift \
            --installer operator \
            --batch \
            --telemetry off \
            --chenamespace "${NAMESPACE}" \
            --che-operator-image "${CHE_OPERATOR_IMAGE}"
        CHECTL_RC=$?
        set -e
        if [ "${CHECTL_RC}" -ne 0 ]; then
            echo -e "${RED}Error: chectl deploy failed again (exit ${CHECTL_RC}).${NC}"
            exit "${CHECTL_RC}"
        fi
    else
        echo -e "${YELLOW}  On IPv6-only clusters this is often caused by missing mirrored images (CatalogSource, bundle-unpack, gateway sidecars).${NC}"
        echo -e "${YELLOW}  Attempting to mirror images discovered from cluster namespaces and retry once...${NC}"

        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        MIRROR_SCRIPT="${SCRIPT_DIR}/mirror-images-to-registry.sh"
        REMEDIATE_ARGS=( --namespace "${NAMESPACE}" --dashboard-image "${DASHBOARD_IMAGE}" --mode "full" )
        if [ -n "${KUBECONFIG_FILE}" ]; then
            REMEDIATE_ARGS+=( --kubeconfig "${KUBECONFIG_FILE}" )
        fi
        REMEDIATE_ARGS+=( --cache-dir "${CACHE_DIR}" )
        if [ -n "${LOCAL_REGISTRY}" ]; then
            REMEDIATE_ARGS+=( --registry "${LOCAL_REGISTRY}" )
        fi
        if [ -n "${QUAY_CREDS}" ]; then
            REMEDIATE_ARGS+=( --quay-creds "${QUAY_CREDS}" )
        fi
        # Discover what the cluster is actually trying to pull.
        REMEDIATE_ARGS+=( --mirror-from-namespace "openshift-marketplace" --mirror-from-namespace "openshift-operators" --mirror-from-namespace "${NAMESPACE}" )

        bash "$MIRROR_SCRIPT" "${REMEDIATE_ARGS[@]}"

        echo -e "${YELLOW}Retrying chectl server:deploy...${NC}"
        set +e
        KUBECONFIG="${CHECTL_KUBECONFIG}" HTTPS_PROXY="${PROXY_URL:-}" HTTP_PROXY="${PROXY_URL:-}" NO_PROXY="${CHECTL_NO_PROXY}" chectl server:deploy \
            --platform openshift \
            --installer operator \
            --batch \
            --telemetry off \
            --chenamespace "${NAMESPACE}" \
            --che-operator-image "${CHE_OPERATOR_IMAGE}"
        CHECTL_RC=$?
        set -e

        if [ "${CHECTL_RC}" -ne 0 ]; then
            echo -e "${RED}Error: chectl deploy failed again (exit ${CHECTL_RC}).${NC}"
            exit "${CHECTL_RC}"
        fi
    fi
fi

echo ""
echo -e "${GREEN}✓ Che deployment initiated${NC}"
echo ""

fi  # End of chectl deployment section

# Step 5: Wait for CheCluster to be created
echo -e "${YELLOW}Step 5: Waiting for CheCluster resource${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

for i in {1..60}; do
    if oc get checluster eclipse-che -n ${NAMESPACE} &>/dev/null; then
        echo -e "${GREEN}✓ CheCluster resource created${NC}"
        break
    fi
    echo "  Waiting for CheCluster resource... ($i/60)"
    sleep 2
done

if ! oc get checluster eclipse-che -n ${NAMESPACE} &>/dev/null; then
    echo -e "${RED}Error: CheCluster resource not created${NC}"
    echo "Check operator logs:"
    echo "  oc logs -n ${NAMESPACE} -l app=che-operator --tail=50"
    exit 1
fi

echo ""

# Step 6: Patch dashboard image to PR-1442 (skip if manual OLM, already done)
if [ "${MANUAL_OLM}" = "false" ]; then
    echo -e "${YELLOW}Step 6: Updating dashboard image to PR-1442${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

    echo -e "${YELLOW}Patching CheCluster...${NC}"

    oc patch checluster eclipse-che -n ${NAMESPACE} --type merge -p "
{
  \"spec\": {
    \"components\": {
      \"dashboard\": {
        \"deployment\": {
          \"containers\": [{
            \"image\": \"${DASHBOARD_IMAGE}\",
            \"imagePullPolicy\": \"Always\",
            \"name\": \"che-dashboard\"
          }]
        }
      }
    }
  }
}"

    echo -e "${GREEN}✓ CheCluster patched with PR-1442 dashboard${NC}"
    echo ""
else
    echo -e "${YELLOW}Step 6: Dashboard image already configured${NC}"
    echo -e "${GREEN}✓ Dashboard image: ${DASHBOARD_IMAGE}${NC}"
    echo ""
fi

# Step 7: Wait for deployment
echo -e "${YELLOW}Step 7: Waiting for pods to be ready${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

echo -e "${YELLOW}Waiting for dashboard deployment...${NC}"
oc wait --for=condition=Available deployment/che-dashboard -n ${NAMESPACE} --timeout=10m 2>/dev/null || true

echo -e "${YELLOW}Waiting for che server deployment...${NC}"
oc wait --for=condition=Available deployment/che -n ${NAMESPACE} --timeout=10m 2>/dev/null || true

echo -e "${YELLOW}Waiting for gateway deployment...${NC}"
oc wait --for=condition=Available deployment/che-gateway -n ${NAMESPACE} --timeout=10m 2>/dev/null || true

echo ""
echo -e "${GREEN}✓ All deployments ready${NC}"
echo ""

# Step 8: Verify deployment
echo -e "${YELLOW}Step 8: Verifying deployment${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# Get dashboard pod
DASHBOARD_POD=$(oc get pods -n ${NAMESPACE} -l app=che-dashboard -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

if [ -n "$DASHBOARD_POD" ]; then
    echo -e "${GREEN}✓ Dashboard pod: ${DASHBOARD_POD}${NC}"

    # Check dashboard image
    ACTUAL_IMAGE=$(oc get pod ${DASHBOARD_POD} -n ${NAMESPACE} -o jsonpath='{.spec.containers[0].image}')
    echo "  Image: ${ACTUAL_IMAGE}"

    if [[ "$ACTUAL_IMAGE" == "$DASHBOARD_IMAGE" ]]; then
        echo -e "${GREEN}  ✓ Correct dashboard image${NC}"
    else
        echo -e "${YELLOW}  ⚠ Warning: Expected ${DASHBOARD_IMAGE}, got: ${ACTUAL_IMAGE}${NC}"
    fi

    # Check pod IPs
    POD_IPS=$(oc get pod ${DASHBOARD_POD} -n ${NAMESPACE} -o jsonpath='{.status.podIPs[*].ip}')
    echo "  Pod IPs: ${POD_IPS}"

    if echo "$POD_IPS" | grep -q ":"; then
        echo -e "${GREEN}  ✓ Pod has IPv6 address${NC}"
    else
        echo -e "${YELLOW}  ⚠ Pod has IPv4 address only (IPv4-only cluster)${NC}"
    fi
else
    echo -e "${YELLOW}⚠ Dashboard pod not found yet${NC}"
fi

echo ""

# Display results
echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
if [ "${DEPLOY_CRW}" = "true" ]; then
    echo -e "${GREEN}║     CodeReady Workspaces Deployed Successfully!            ║${NC}"
else
    echo -e "${GREEN}║         Eclipse Che Deployed Successfully!                 ║${NC}"
fi
echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Get Che URL
CHE_URL=$(oc get checluster ${OPERATOR_NAME} -n ${NAMESPACE} -o jsonpath='{.status.cheURL}' 2>/dev/null || echo "Not available yet")

echo -e "${BLUE}Access Information:${NC}"
echo "  Che URL:       ${CHE_URL}"
echo "  Dashboard:     ${CHE_URL}/dashboard/"
echo "  Namespace:     ${NAMESPACE}"
echo ""

# Get route
ROUTE_HOST=$(oc get route che -n ${NAMESPACE} -o jsonpath='{.spec.host}' 2>/dev/null || echo "N/A")
echo -e "${BLUE}Route:${NC}"
echo "  Host: ${ROUTE_HOST}"
echo ""

echo -e "${BLUE}Dashboard Image:${NC}"
DASHBOARD_IMAGE_ACTUAL=$(oc get deployment che-dashboard -n ${NAMESPACE} -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "N/A")
echo "  ${DASHBOARD_IMAGE_ACTUAL}"
echo ""

if [[ "$IPV6_ENABLED" == "true" ]]; then
    echo -e "${BLUE}IPv6 Status:${NC}"
    echo -e "${GREEN}  ✓ Cluster supports IPv6${NC}"
    echo "  ✓ Dashboard includes IPv6 URL validation"
    echo "  ✓ Backend supports dual-stack networking"
    echo "  Service network: ${IPV6_SERVICE_NET}"
    echo "  Pod network: ${IPV6_POD_NET}"
else
    echo -e "${BLUE}IPv6 Status:${NC}"
    echo -e "${YELLOW}  ⚠ Cluster is IPv4-only${NC}"
    echo "  ✓ Dashboard includes IPv6 URL validation (frontend)"
    echo "  ✓ Backend binds to :: (dual-stack ready)"
    echo "  ℹ For dual-stack IPv6 testing, use cluster bot:"
    echo "    launch 4.20.2 metal,ipv6"
fi
echo ""

echo -e "${BLUE}Pods in ${NAMESPACE}:${NC}"
oc get pods -n ${NAMESPACE}
echo ""

echo -e "${BLUE}Services:${NC}"
oc get svc -n ${NAMESPACE} -o custom-columns=\
NAME:.metadata.name,\
TYPE:.spec.type,\
IP-POLICY:.spec.ipFamilyPolicy,\
CLUSTER-IPS:.spec.clusterIPs
echo ""

echo -e "${BLUE}Useful Commands:${NC}"
echo "  Check status:       chectl server:status"
echo "  View dashboard logs: oc logs -n ${NAMESPACE} -l app=che-dashboard -f"
echo "  View che logs:      oc logs -n ${NAMESPACE} -l app=che -f"
echo "  Delete Che:         chectl server:delete -n ${NAMESPACE}"
echo "  Cluster info:       oc get checluster eclipse-che -n ${NAMESPACE}"
echo "  Port forward:       oc port-forward -n ${NAMESPACE} svc/che-host 8080:8080"
echo ""

echo -e "${BLUE}Testing:${NC}"
echo "  1. Access dashboard: ${CHE_URL}/dashboard/"
echo "  2. Run IPv6 tests:   ./test-ipv6-validation.sh"
echo "  3. Read testing guide: cat test-ipv6-validation.md"
echo ""

echo -e "${BLUE}Next Steps:${NC}"
echo "  1. Open dashboard and test IPv6 URL validation in browser console"
echo "  2. Test Data Resolver API with IPv6 URLs (see testing-data-resolver-api.md)"
echo "  3. Create workspaces with IPv6 Git repositories"
echo ""

echo -e "${GREEN}✓ Deployment complete!${NC}"
