#!/bin/bash
# Mirror Eclipse Che images to local IPv6 cluster registry
#
# This script mirrors all required images for Eclipse Che deployment
# to a local registry that's accessible from an IPv6-only cluster.
#
# Prerequisites:
# - skopeo installed (for image mirroring)
# - oc CLI configured with cluster access
# - Access to local registry
#
# Usage:
#   ./mirror-images-to-registry.sh [options]
#
# Options:
#   --kubeconfig <file>      Path to kubeconfig file (uses proxy-url from kubeconfig)
#   --registry <host:port>   Local registry (default: auto-detect from cluster)
#   --namespace <namespace>  Che namespace (default: eclipse-che)
#   --dashboard-image <image> Dashboard image (default: quay.io/eclipse/che-dashboard:pr-1442)
#   --mirror-from-namespace <ns>
#                           Additionally mirror images referenced by Pods in this namespace.
#                           Can be specified multiple times (e.g. openshift-marketplace, openshift-operators, eclipse-che).
#   --mode <minimal|full>    Images set to mirror:
#                             - minimal: Che + registries + cert-manager (no DevWorkspace/UDI)
#                             - full:    minimal + DevWorkspace images + UDI (recommended for workspace tests)
#   --quay-creds <user:pass> Optional Quay credentials for private images (used as --src-creds for skopeo)
#   --parallel <N>          Number of concurrent skopeo copy processes (default: 1)
#   --heartbeat-seconds <N> Print periodic progress/heartbeat messages (default: 60)
#   --skopeo-log-level <L>  Pass log level to skopeo (e.g. debug, info). Default: skopeo default.
#   --dry-run               Show what would be mirrored without doing it
#   --help                  Show this help message
#
# Troubleshooting:
#   If Eclipse Che deployment fails with "manifest unknown" for an OLM bundle image:
#   1. Check pod events: oc get events -n eclipse-che --sort-by='.lastTimestamp'
#   2. Look for errors like: "Failed to pull image quay.io/eclipse/...-bundle@sha256:..."
#   3. Add the missing bundle digest to the static list around line 302
#   4. Re-run this script to mirror the missing bundle
#   5. Retry deployment
#
# Generated by Claude Sonnet 4.5
#
# Generated by GPT-5.2

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default configuration
LOCAL_REGISTRY=""
NAMESPACE="eclipse-che"
DASHBOARD_IMAGE="quay.io/eclipse/che-dashboard:pr-1442"
CHE_OPERATOR_IMAGE="quay.io/eclipse/che-operator:next"
MODE="full"
QUAY_CREDS="${QUAY_CREDS:-}"
DRY_RUN=false
KUBECONFIG_FILE=""
MIRROR_FROM_NAMESPACES=()
# Prefetch/cache options
# Generated by GPT-5.2
CACHE_DIR="${CACHE_DIR:-${HOME}/.cache/che-ipv6-mirror}"
PREFETCH_ONLY=false
USE_CACHE=true
# Per-image timeout guard (seconds) for skopeo copy to avoid hangs.
# Generated by GPT-5.2
SKOPEO_TIMEOUT_SECONDS="${SKOPEO_TIMEOUT_SECONDS:-900}"
# Output/performance tuning
# Generated by GPT-5.2
SKOPEO_LOG_LEVEL="${SKOPEO_LOG_LEVEL:-}"
HEARTBEAT_SECONDS="${HEARTBEAT_SECONDS:-60}"
PARALLEL="${PARALLEL:-1}"

# Helpers
extract_proxy_url_from_kubeconfig() {
    # Reads the first "proxy-url:" entry from the kubeconfig (cluster-bot kubeconfigs often include it).
    # Returns empty string if not found.
    local kc="${1:-}"
    if [ -n "${kc}" ] && [ -f "${kc}" ]; then
        grep -m1 'proxy-url:' "${kc}" 2>/dev/null | awk '{print $2}' || true
    else
        grep -m1 'proxy-url:' "${KUBECONFIG:-}" 2>/dev/null | awk '{print $2}' || true
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --kubeconfig)
            KUBECONFIG_FILE="$2"
            shift 2
            ;;
        --registry)
            LOCAL_REGISTRY="$2"
            shift 2
            ;;
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --dashboard-image)
            DASHBOARD_IMAGE="$2"
            shift 2
            ;;
        --mirror-from-namespace)
            MIRROR_FROM_NAMESPACES+=("$2")
            shift 2
            ;;
        --mode)
            MODE="$2"
            shift 2
            ;;
        --quay-creds)
            QUAY_CREDS="$2"
            shift 2
            ;;
        --skopeo-log-level)
            SKOPEO_LOG_LEVEL="$2"
            shift 2
            ;;
        --heartbeat-seconds)
            HEARTBEAT_SECONDS="$2"
            shift 2
            ;;
        --parallel)
            PARALLEL="$2"
            shift 2
            ;;
        --cache-dir)
            CACHE_DIR="$2"
            shift 2
            ;;
        --prefetch-only)
            PREFETCH_ONLY=true
            shift
            ;;
        --use-cache)
            USE_CACHE=true
            shift
            ;;
        --no-cache)
            USE_CACHE=false
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            grep '^#' "$0" | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate mode
if [ "${MODE}" != "minimal" ] && [ "${MODE}" != "full" ]; then
    echo -e "${RED}Error: Invalid --mode '${MODE}'. Expected 'minimal' or 'full'.${NC}"
    exit 1
fi

# Validate tuning flags
if ! [[ "${PARALLEL}" =~ ^[0-9]+$ ]] || [ "${PARALLEL}" -lt 1 ]; then
    echo -e "${RED}Error: Invalid --parallel '${PARALLEL}'. Expected integer >= 1.${NC}"
    exit 1
fi
if ! [[ "${HEARTBEAT_SECONDS}" =~ ^[0-9]+$ ]] || [ "${HEARTBEAT_SECONDS}" -lt 1 ]; then
    echo -e "${RED}Error: Invalid --heartbeat-seconds '${HEARTBEAT_SECONDS}'. Expected integer >= 1.${NC}"
    exit 1
fi
if [ -n "${SKOPEO_LOG_LEVEL}" ]; then
    case "${SKOPEO_LOG_LEVEL}" in
        fatal|panic|error|warn|warning|info|debug|trace) ;;
        *)
            echo -e "${RED}Error: Invalid --skopeo-log-level '${SKOPEO_LOG_LEVEL}'. Expected one of: fatal|panic|error|warn|info|debug|trace.${NC}"
            exit 1
            ;;
    esac
fi

# Set KUBECONFIG if provided
if [ -n "$KUBECONFIG_FILE" ]; then
    if [ ! -f "$KUBECONFIG_FILE" ]; then
        echo -e "${RED}Error: Kubeconfig file not found: $KUBECONFIG_FILE${NC}"
        exit 1
    fi
    export KUBECONFIG="$KUBECONFIG_FILE"
    echo -e "${GREEN}✓ Using kubeconfig: $KUBECONFIG_FILE${NC}"
    echo ""
fi

# Expand dashboard image shortcuts (pr-XXXX, next, latest)
case "$DASHBOARD_IMAGE" in
    pr-*)
        DASHBOARD_IMAGE="quay.io/eclipse/che-dashboard:$DASHBOARD_IMAGE"
        ;;
    next)
        DASHBOARD_IMAGE="quay.io/eclipse/che-dashboard:next"
        ;;
    latest)
        DASHBOARD_IMAGE="quay.io/eclipse/che-dashboard:latest"
        ;;
esac

echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║     Mirror Eclipse Che Images to Local Registry           ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Check prerequisites
echo -e "${YELLOW}Step 1: Checking prerequisites${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

if ! command -v skopeo &> /dev/null; then
    echo -e "${RED}Error: skopeo not found${NC}"
    echo ""
    echo "Install skopeo:"
    echo "  # macOS"
    echo "  brew install skopeo"
    echo ""
    echo "  # RHEL/Fedora"
    echo "  sudo dnf install skopeo"
    echo ""
    echo "  # Ubuntu/Debian"
    echo "  sudo apt-get install skopeo"
    exit 1
fi
echo -e "${GREEN}✓ skopeo found: $(skopeo --version | head -1)${NC}"

if [ "${PREFETCH_ONLY}" != "true" ]; then
    if ! command -v oc &> /dev/null; then
        echo -e "${RED}Error: oc not found${NC}"
        exit 1
    fi
    echo -e "${GREEN}✓ oc CLI found${NC}"
else
    echo -e "${YELLOW}⚠ Prefetch-only mode: skipping oc/cluster checks${NC}"
fi

if [ "${PREFETCH_ONLY}" != "true" ]; then
    # Auto-detect local registry from cluster (cluster-bot clusters usually have this configured).
    if [ -z "$LOCAL_REGISTRY" ]; then
        echo -e "${YELLOW}Auto-detecting local registry from cluster...${NC}"
        LOCAL_REGISTRY=$(oc get imagecontentsourcepolicy -o jsonpath='{.items[0].spec.repositoryDigestMirrors[0].mirrors[0]}' 2>/dev/null | sed 's|/.*||' || echo "")

        if [ -z "$LOCAL_REGISTRY" ]; then
            echo -e "${RED}Error: Could not auto-detect local registry${NC}"
            echo "Please specify with --registry flag"
            exit 1
        fi
        echo -e "${GREEN}✓ Detected registry: ${LOCAL_REGISTRY}${NC}"
    fi
fi

# Get registry credentials
REGISTRY_USER=""
REGISTRY_PASS=""
if [ "${PREFETCH_ONLY}" != "true" ]; then
    echo -e "${YELLOW}Extracting registry credentials...${NC}"

    # Extract destination registry basic auth (if present) from the cluster pull-secret
    REGISTRY_AUTH=$(oc get secret pull-secret -n openshift-config -o jsonpath='{.data.\.dockerconfigjson}' 2>/dev/null | base64 -d | python3 -c "import sys, json; data=json.load(sys.stdin); print(data['auths'].get('${LOCAL_REGISTRY}', {}).get('auth', ''))" || echo "")

    if [ -z "$REGISTRY_AUTH" ]; then
        echo -e "${YELLOW}⚠ No auth found for ${LOCAL_REGISTRY}, will try without authentication${NC}"
    else
        # Decode base64 auth (format: username:password)
        REGISTRY_CREDS=$(echo "$REGISTRY_AUTH" | base64 -d)
        REGISTRY_USER=$(echo "$REGISTRY_CREDS" | cut -d: -f1)
        REGISTRY_PASS=$(echo "$REGISTRY_CREDS" | cut -d: -f2-)
        echo -e "${GREEN}✓ Found credentials for ${LOCAL_REGISTRY} (user: ${REGISTRY_USER})${NC}"
    fi
fi

echo ""

# Define images to mirror
echo -e "${YELLOW}Step 2: Defining images to mirror${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# List of images to mirror (bash 3.2 compatible)
IMAGES=()

# Base set (required for Che core + registries)
IMAGES+=(
  "${CHE_OPERATOR_IMAGE}"
  "${DASHBOARD_IMAGE}"
  "quay.io/eclipse/che-server:next"
  # Gateway uses configbump:next
  "quay.io/che-incubator/configbump:next"
  # Gateway sidecars on OpenShift
  "quay.io/openshift/origin-oauth-proxy:4.9"
  "quay.io/openshift/origin-kube-rbac-proxy:4.9"
  # Eclipse Che OLM catalog (CatalogSource created by chectl)
  "quay.io/eclipse/eclipse-che-olm-catalog:next"

  # Registries (Che components)
  "quay.io/eclipse/che-plugin-registry:next"
  "quay.io/eclipse/che-devfile-registry:next"
)

# Full set adds DevWorkspace + UDI, required for workspace creation tests.
if [ "${MODE}" = "full" ]; then
  IMAGES+=(
    # Required by OLM CatalogSource created by chectl (devworkspace-operator-index:next)
    "quay.io/devfile/devworkspace-operator-index:next"
    "quay.io/devfile/devworkspace-controller:next"
    "quay.io/devfile/project-clone:next"
    "quay.io/devfile/universal-developer-image:ubi9-latest"

    # OLM bundle images (referenced by catalog indices via digest)
    # These are unpacked by OLM during operator installation
    # NOTE: These digests may change when operator versions update
    # If deployment fails with "manifest unknown" for a bundle, add the missing digest here
    # "quay.io/devfile/devworkspace-operator-bundle@sha256:a3fb42e76b477cc00f4833be380efde57503802082ce07985e55dd5f96a1d597"  # Manifest no longer exists in quay.io
    "quay.io/eclipse/eclipse-che-olm-bundle@sha256:b525748e410cf2ddb405209ac5bce7b4ed2e401b7141f6c4edcea0e32e5793a1"

    # Gateway (traefik) image - required by che-gateway pod
    # This image is referenced via RELATED_IMAGE_single_host_gateway in the Che operator
    # NOTE: This tag includes a commit hash and may change when Che operator updates
    "quay.io/eclipse/che--traefik:v3.6.7-2c5e029ee3638d3788b4ca7c8ef454baa8f924b91b190b3fd2742bee721ebeea"

    # Test infrastructure images - required by IPv6 validation test script
    # Used by test-ipv6-validation.sh to deploy devfile and git servers
    "docker.io/library/python:3.11-alpine"
    "docker.io/alpine/git:latest"
  )
fi

# Optionally discover additional images from namespaces (helps when operators pin sha-* tags/digests).
if [ "${#MIRROR_FROM_NAMESPACES[@]}" -gt 0 ]; then
  if [ "${PREFETCH_ONLY}" = "true" ]; then
    echo -e "${YELLOW}⚠ --mirror-from-namespace ignored in --prefetch-only mode (requires cluster access).${NC}"
    echo ""
  else
    echo -e "${YELLOW}Discovering images from namespaces:${NC} ${MIRROR_FROM_NAMESPACES[*]}"
    for NS in "${MIRROR_FROM_NAMESPACES[@]}"; do
      # Best-effort: if namespace doesn't exist yet, skip.
      if ! oc get ns "${NS}" >/dev/null 2>&1; then
        echo -e "${YELLOW}  ⚠ Namespace not found (skipping): ${NS}${NC}"
        continue
      fi

      while IFS= read -r img; do
        [ -z "${img}" ] && continue
        # Ignore images which are known to be private/payload-internal and may be already present on nodes.
        # These frequently break dynamic mirroring with "unauthorized" and are not needed for Che images.
        # Generated by GPT-5.2
        case "${img}" in
          quay.io/openshift-release-dev/*) continue ;;
        esac
        # Skip already-mirrored registry references
        if echo "${img}" | grep -q "^${LOCAL_REGISTRY}/"; then
          continue
        fi
        IMAGES+=("${img}")
      done < <(
        oc get pods -n "${NS}" -o jsonpath='{range .items[*]}{range .spec.initContainers[*]}{.image}{"\n"}{end}{range .spec.containers[*]}{.image}{"\n"}{end}{end}' 2>/dev/null \
          | sed '/^$/d' \
          | sort -u
      )
    done
    echo ""
  fi
fi

# Extract OLM bundle images from catalog indices
# OLM catalog indices contain references to bundle images by digest that aren't visible
# until the catalog is unpacked. On IPv6-only clusters, these must be pre-mirrored.
# Generated by Claude Sonnet 4.5
#
# NOTE: Dynamic bundle discovery disabled due to skopeo/Python compatibility issues on macOS.
# The static bundle list (line 302) is sufficient for current Che deployment.
# On Linux clusters, you can use `opm render` to discover additional bundles if needed.
if false && [ "${MODE}" = "full" ] && [ "${PREFETCH_ONLY}" = "false" ]; then
  echo -e "${YELLOW}Extracting OLM bundle images from catalog indices...${NC}"

  CATALOG_INDICES=(
    "quay.io/devfile/devworkspace-operator-index:next"
    "quay.io/eclipse/eclipse-che-olm-catalog:next"
  )

  for CATALOG_INDEX in "${CATALOG_INDICES[@]}"; do
    echo "  Inspecting: ${CATALOG_INDEX}"

    # Use skopeo to inspect the catalog index and extract bundle image references
    # Catalog indices are OPM (Operator Package Manager) format with bundle references in layers
    # Use --override-os/--override-arch for macOS compatibility (catalog indices are Linux-only)
    BUNDLE_IMAGES=$(skopeo inspect --override-os linux --override-arch amd64 "docker://${CATALOG_INDEX}" 2>/dev/null | \
      python3 - <<'PY' "${CATALOG_INDEX}"
import json, sys, re

catalog_ref = sys.argv[1] if len(sys.argv) > 1 else "unknown"
try:
    manifest = json.load(sys.stdin)

    # Try to extract bundle references from the manifest
    # OLM catalog indices may have bundle refs in various places depending on format
    bundles = []

    # Method 1: Check if there are related images (FBC/Declarative config format)
    if "RelatedImages" in manifest:
        for img in manifest.get("RelatedImages", []):
            if isinstance(img, dict) and "image" in img:
                bundles.append(img["image"])
            elif isinstance(img, str):
                bundles.append(img)

    # Method 2: Check config for bundle references (older SQLite format)
    config = manifest.get("Config", {})
    if isinstance(config, dict):
        env = config.get("Env", [])
        for e in env:
            # Look for environment variables containing bundle references
            if "BUNDLE_IMAGE" in e or "RELATED_IMAGE" in e:
                match = re.search(r'quay\.io/[^\s"]+@sha256:[a-f0-9]{64}', e)
                if match:
                    bundles.append(match.group(0))

    # Method 3: Extract from layers/history (bundle refs often in metadata)
    for layer in manifest.get("Layers", []):
        if isinstance(layer, dict):
            annotations = layer.get("annotations", {})
            for key, value in annotations.items():
                if "bundle" in key.lower() and "@sha256:" in value:
                    bundles.append(value)

    # Output unique bundle images
    for bundle in sorted(set(bundles)):
        if bundle and ("operator-bundle@sha256:" in bundle or "che-olm-bundle@sha256:" in bundle):
            print(bundle)

except Exception as e:
    # If inspection fails, we'll fall back to discovering bundles from running pods
    sys.stderr.write(f"Warning: Could not extract bundles from {catalog_ref}: {e}\n")
    pass
PY
)

    # Add discovered bundle images to the mirror list
    if [ -n "$BUNDLE_IMAGES" ]; then
      while IFS= read -r BUNDLE_IMG; do
        if [ -n "$BUNDLE_IMG" ]; then
          echo "    Found bundle: ${BUNDLE_IMG}"
          IMAGES+=("${BUNDLE_IMG}")
        fi
      done <<< "$BUNDLE_IMAGES"
    else
      # Fallback: Use opm if available to render the catalog
      if command -v opm &> /dev/null; then
        echo "    Trying opm render (fallback)..."
        BUNDLE_IMAGES=$(opm render "${CATALOG_INDEX}" 2>/dev/null | grep -oP 'image:\s*\K[^\s]+@sha256:[a-f0-9]{64}' || echo "")
        while IFS= read -r BUNDLE_IMG; do
          if [ -n "$BUNDLE_IMG" ]; then
            echo "    Found bundle: ${BUNDLE_IMG}"
            IMAGES+=("${BUNDLE_IMG}")
          fi
        done <<< "$BUNDLE_IMAGES"
      else
        echo -e "${YELLOW}    ⚠ Could not extract bundles (opm not available, will discover from running pods)${NC}"
      fi
    fi
  done
  echo ""
fi

echo "Will mirror ${#IMAGES[@]} images:"
for SOURCE_IMAGE in "${IMAGES[@]}"; do
    echo "  - ${SOURCE_IMAGE}"
done
echo ""

# Cache helpers
# Generated by GPT-5.2
cache_safe_name() {
    local image_ref="${1:-}"
    python3 - <<'PY' "${image_ref}"
import re, sys
ref = sys.argv[1]
# Replace anything that's not filesystem-safe with '_'
print(re.sub(r'[^A-Za-z0-9._-]+', '_', ref).strip('_'))
PY
}

# Generated by GPT-5.2
cache_tar_for_image() {
    local image_ref="${1:-}"
    local arch="${2:-amd64}"
    local safe
    safe="$(cache_safe_name "${image_ref}")"
    echo "${CACHE_DIR}/${safe}__linux_${arch}.oci.tar"
}

# Run a shell command with a timeout (kills entire process group).
# Generated by GPT-5.2
run_with_timeout_shell() {
    local timeout_seconds="${1:-900}"
    local heartbeat_seconds="${2:-60}"
    local label="${3:-}"
    shift
    shift
    shift
    local cmd="${1:-}"
    python3 - <<'PY' "${timeout_seconds}" "${heartbeat_seconds}" "${label}" "${cmd}"
import os, signal, subprocess, sys, time
timeout = int(sys.argv[1])
heartbeat = int(sys.argv[2])
label = sys.argv[3]
cmd = sys.argv[4]
p = subprocess.Popen(cmd, shell=True, preexec_fn=os.setsid)
start = time.time()
last = start
try:
    while True:
        rc = p.poll()
        if rc is not None:
            sys.exit(rc)
        now = time.time()
        if heartbeat > 0 and (now - last) >= heartbeat:
            elapsed = int(now - start)
            msg = f"[mirror] still running ({elapsed}s)"
            if label:
                msg = f"[mirror] {label}: still running ({elapsed}s)"
            print(msg, file=sys.stderr, flush=True)
            last = now
        if timeout > 0 and (now - start) >= timeout:
            raise subprocess.TimeoutExpired(cmd, timeout)
        time.sleep(1)
except subprocess.TimeoutExpired:
    try:
        os.killpg(p.pid, signal.SIGTERM)
    except Exception:
        pass
    time.sleep(2)
    try:
        if p.poll() is None:
            os.killpg(p.pid, signal.SIGKILL)
    except Exception:
        pass
    elapsed = int(time.time() - start)
    msg = f"[mirror] timed out after {elapsed}s"
    if label:
        msg = f"[mirror] {label}: timed out after {elapsed}s"
    print(msg, file=sys.stderr, flush=True)
    sys.exit(124)
PY
}

# Build skopeo command prefix (log level).
# Generated by GPT-5.2
skopeo_prefix() {
    # skopeo 1.19 supports a global --debug flag but does NOT support --log-level.
    # Map debug/trace to --debug and ignore other levels (keep skopeo defaults).
    # Generated by GPT-5.2
    case "${SKOPEO_LOG_LEVEL:-}" in
        debug|trace)
            echo "skopeo --debug"
            ;;
        *)
            echo "skopeo"
            ;;
    esac
}

# Mirror images
echo -e "${YELLOW}Step 3: Mirroring images${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

MIRRORED=0
FAILED=0

# Decide whether we need multi-arch mirroring.
# On a typical cluster-bot metal cluster, all nodes are linux/amd64; mirroring only that platform
# significantly reduces transfer size and avoids timeouts on very large images (e.g. UDI).
SINGLE_ARCH=""
if [ "${PREFETCH_ONLY}" = "true" ]; then
    SINGLE_ARCH="${CHE_MIRROR_ARCH:-amd64}"
else
    CLUSTER_ARCHS="$(oc get nodes -o jsonpath='{range .items[*]}{.status.nodeInfo.architecture}{"\n"}{end}' 2>/dev/null | sed '/^$/d' | sort -u || true)"
    ARCH_COUNT="$(echo "${CLUSTER_ARCHS}" | sed '/^$/d' | wc -l | tr -d ' ' || echo "0")"
    SINGLE_ARCH="$(echo "${CLUSTER_ARCHS}" | head -1 || true)"
fi
SKOPEO_ALL_FLAG="--all"
SKOPEO_PLATFORM_FLAGS=""
if [ -n "${SINGLE_ARCH}" ]; then
    SKOPEO_ALL_FLAG=""
    SKOPEO_PLATFORM_FLAGS="--override-os linux --override-arch ${SINGLE_ARCH}"
    echo -e "${YELLOW}Detected single cluster architecture: linux/${SINGLE_ARCH}${NC}"
    echo -e "${YELLOW}Will mirror only linux/${SINGLE_ARCH} (not all platforms)${NC}"
    echo ""
fi

# Cache directory
if [ "${USE_CACHE}" = "true" ] || [ "${PREFETCH_ONLY}" = "true" ]; then
    mkdir -p "${CACHE_DIR}"
    echo -e "${YELLOW}Using cache dir: ${CACHE_DIR}${NC}"
    echo ""
fi

# Prefetch-only mode: populate cache and exit
if [ "${PREFETCH_ONLY}" = "true" ]; then
    echo -e "${YELLOW}Prefetch-only mode: downloading images to OCI archives${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

    for SOURCE_IMAGE in "${IMAGES[@]}"; do
        local_tar="$(cache_tar_for_image "${SOURCE_IMAGE}" "${SINGLE_ARCH:-amd64}")"
        if [ -f "${local_tar}" ]; then
            echo -e "${GREEN}✓ Cached (skip): ${SOURCE_IMAGE}${NC}"
            continue
        fi
        echo -e "${BLUE}Prefetching: ${SOURCE_IMAGE}${NC}"
        if [ "$DRY_RUN" == "true" ]; then
            echo -e "${YELLOW}  [DRY RUN] Would prefetch to ${local_tar}${NC}"
            continue
        fi

        # Build skopeo command (store a single image per archive; include reference for unambiguous reads)
        # Generated by GPT-5.2
        SKOPEO_CMD="$(skopeo_prefix) copy ${SKOPEO_PLATFORM_FLAGS}"
        if [ -n "${QUAY_CREDS}" ]; then
            SKOPEO_CMD="${SKOPEO_CMD} --src-creds ${QUAY_CREDS}"
        fi
        SKOPEO_CMD="${SKOPEO_CMD} docker://${SOURCE_IMAGE} oci-archive:${local_tar}:${SOURCE_IMAGE}"

        if run_with_timeout_shell "${SKOPEO_TIMEOUT_SECONDS}" "${HEARTBEAT_SECONDS}" "${SOURCE_IMAGE}" "${SKOPEO_CMD}"; then
            echo -e "${GREEN}  ✓ Prefetched${NC}"
            MIRRORED=$((MIRRORED + 1))
        else
            echo -e "${RED}  ✗ Prefetch failed${NC}"
            FAILED=$((FAILED + 1))
        fi
        echo ""
    done

    echo -e "${GREEN}✓ Prefetch completed. Cached: ${MIRRORED}, Failed: ${FAILED}${NC}"
    if [ $FAILED -gt 0 ]; then
        exit 1
    fi
    exit 0
fi

# Use kubeconfig proxy-url (if present) for tools that do NOT honor kubeconfig proxy-url (e.g. skopeo).
# Important: keep quay.io and RH registries in NO_PROXY so we can pull directly, while pushing to the
# cluster-local registry via the proxy.
PROXY_URL="$(extract_proxy_url_from_kubeconfig "${KUBECONFIG_FILE}")"
SKOPEO_ENV_PREFIX=""
if [ -n "${PROXY_URL}" ]; then
    SKOPEO_ENV_PREFIX="HTTP_PROXY=${PROXY_URL} HTTPS_PROXY=${PROXY_URL} NO_PROXY=localhost,127.0.0.1,quay.io,registry.redhat.io,registry.access.redhat.com"
    echo -e "${YELLOW}Using kubeconfig proxy for skopeo push: ${PROXY_URL}${NC}"
fi

DEST_TLS_VERIFY_FLAG="--dest-tls-verify=false"

# Mirror worker (one image). Writes a one-line status file.
# Generated by GPT-5.2
mirror_one_image() {
    local source_image="${1:-}"
    local status_file="${2:-}"

    # Determine destination path
    IMAGE_PATH=$(echo "${source_image}" | sed 's|^[^/]*/||')
    # If source uses a digest reference, do NOT push to a digest reference (many registries reject that).
    # Push to a synthetic tag derived from the digest; the manifest digest is preserved and can be pulled by digest.
    # Generated by GPT-5.2
    if [[ "${IMAGE_PATH}" == *@sha256:* ]]; then
        IMAGE_REPO="${IMAGE_PATH%@sha256:*}"
        IMAGE_DIGEST="${IMAGE_PATH#*@}" # sha256:...
        DIGEST_TAG="sha256-${IMAGE_DIGEST#sha256:}"
        DEST_IMAGE="${LOCAL_REGISTRY}/eclipse-che/${IMAGE_REPO}:${DIGEST_TAG}"
    else
        DEST_IMAGE="${LOCAL_REGISTRY}/eclipse-che/${IMAGE_PATH}"
    fi

    IMAGE_NAME=$(echo "${source_image}" | awk -F'/' '{print $NF}')
    echo -e "${BLUE}Mirroring: ${IMAGE_NAME}${NC}"
    echo "  From: ${source_image}"
    echo "  To:   ${DEST_IMAGE}"

    if [ "$DRY_RUN" == "true" ]; then
        echo -e "${YELLOW}  [DRY RUN] Would mirror image${NC}"
        echo "ok" > "${status_file}"
        echo ""
        return 0
    fi

    SOURCE_TRANSPORT="docker://${source_image}"
    if [ "${USE_CACHE}" = "true" ]; then
        cache_tar="$(cache_tar_for_image "${source_image}" "${SINGLE_ARCH:-amd64}")"
        if [ -f "${cache_tar}" ]; then
            SOURCE_TRANSPORT="oci-archive:${cache_tar}:${source_image}"
            echo -e "${YELLOW}  Using cached OCI archive: ${cache_tar}${NC}"
        fi
    fi

    # For digest references, preserve the *exact* referenced digest.
    # On single-arch clusters we normally use --override-arch, but that changes the digest when the source is a manifest list.
    # Generated by GPT-5.2
    COPY_ALL_FLAG="${SKOPEO_ALL_FLAG}"
    COPY_PLATFORM_FLAGS="${SKOPEO_PLATFORM_FLAGS}"
    if [[ "${source_image}" == *@sha256:* ]]; then
        COPY_ALL_FLAG="--all"
        COPY_PLATFORM_FLAGS=""
    fi

    SKOPEO_CMD="$(skopeo_prefix) copy ${COPY_ALL_FLAG} ${COPY_PLATFORM_FLAGS}"
    if [ -n "${QUAY_CREDS}" ]; then
        SKOPEO_CMD="${SKOPEO_CMD} --src-creds ${QUAY_CREDS}"
    fi
    if [ -n "${REGISTRY_USER}" ] && [ -n "${REGISTRY_PASS}" ]; then
        SKOPEO_CMD="${SKOPEO_CMD} --dest-creds ${REGISTRY_USER}:${REGISTRY_PASS}"
    fi
    SKOPEO_CMD="${SKOPEO_CMD} ${DEST_TLS_VERIFY_FLAG}"
    SKOPEO_CMD="${SKOPEO_CMD} ${SOURCE_TRANSPORT} docker://${DEST_IMAGE}"

    MIRROR_OK=false
    for attempt in 1 2 3; do
        if [ -n "${SKOPEO_ENV_PREFIX}" ]; then
            if run_with_timeout_shell "${SKOPEO_TIMEOUT_SECONDS}" "${HEARTBEAT_SECONDS}" "${IMAGE_NAME}" "${SKOPEO_ENV_PREFIX} ${SKOPEO_CMD}"; then
                MIRROR_OK=true
                break
            fi
        elif run_with_timeout_shell "${SKOPEO_TIMEOUT_SECONDS}" "${HEARTBEAT_SECONDS}" "${IMAGE_NAME}" "${SKOPEO_CMD}"; then
            MIRROR_OK=true
            break
        fi

        if [ "${attempt}" -lt 3 ]; then
            echo -e "${YELLOW}  ⚠ Mirror failed (attempt ${attempt}/3), retrying...${NC}"
            sleep $((attempt * 10))
        fi
    done

    if [ "${MIRROR_OK}" = "true" ]; then
        echo -e "${GREEN}  ✓ Mirrored successfully${NC}"
        echo "ok" > "${status_file}"
    else
        echo -e "${RED}  ✗ Failed to mirror${NC}"
        echo "fail" > "${status_file}"
    fi
    echo ""
}

# Parallel queue runner
# Generated by GPT-5.2
STATUS_DIR="$(mktemp -d "/tmp/che-mirror-status.XXXXXX")"
trap 'rm -rf "${STATUS_DIR}" >/dev/null 2>&1 || true' EXIT

active_pids=()
active_files=()

enqueue_job() {
    local source_image="${1:-}"
    local idx="${2:-0}"
    local status_file="${STATUS_DIR}/status.${idx}.txt"
    : > "${status_file}"
    (
      mirror_one_image "${source_image}" "${status_file}"
    ) &
    active_pids+=("$!")
    active_files+=("${status_file}")
}

drain_finished() {
    # Bash 3.2 + nounset safe: declare arrays explicitly and use an index loop.
    # Generated by GPT-5.2
    unset kept_pids kept_files >/dev/null 2>&1 || true
    declare -a kept_pids kept_files
    kept_pids=()
    kept_files=()

    local i pid
    for ((i = 0; i < ${#active_pids[@]}; i++)); do
        pid="${active_pids[$i]}"
        if kill -0 "${pid}" >/dev/null 2>&1; then
            kept_pids+=("${pid}")
            kept_files+=("${active_files[$i]}")
        fi
    done

    # With "set -u" on bash 3.2, expanding an empty array (e.g. "${arr[@]}")
    # triggers "unbound variable". Assign empty first, then overwrite only if non-empty.
    # Generated by GPT-5.2
    active_pids=()
    active_files=()
    if [ "${#kept_pids[@]}" -gt 0 ]; then
        active_pids=("${kept_pids[@]}")
        active_files=("${kept_files[@]}")
    fi
}

wait_for_any_slot() {
    while [ "${#active_pids[@]}" -ge "${PARALLEL}" ]; do
        sleep 1
        drain_finished
    done
}

collect_results() {
    local ok=0
    local fail=0
    local f
    for f in "${STATUS_DIR}"/status.*.txt; do
        [ -f "${f}" ] || continue
        if grep -q "^ok$" "${f}" 2>/dev/null; then
            ok=$((ok + 1))
        elif grep -q "^fail$" "${f}" 2>/dev/null; then
            fail=$((fail + 1))
        fi
    done
    echo "${ok} ${fail}"
}

echo -e "${YELLOW}Parallel mirroring: ${PARALLEL} concurrent copies${NC}"
echo ""

job_idx=0
last_summary_ts="$(date +%s)"

for SOURCE_IMAGE in "${IMAGES[@]}"; do
    wait_for_any_slot
    enqueue_job "${SOURCE_IMAGE}" "${job_idx}"
    job_idx=$((job_idx + 1))

    now_ts="$(date +%s)"
    if [ $((now_ts - last_summary_ts)) -ge "${HEARTBEAT_SECONDS}" ]; then
        read ok_count fail_count < <(collect_results)
        echo -e "${YELLOW}[mirror] progress: ok=${ok_count} fail=${fail_count} running=${#active_pids[@]} total=${#IMAGES[@]}${NC}"
        last_summary_ts="${now_ts}"
    fi
done

# Wait for all remaining jobs
while [ "${#active_pids[@]}" -gt 0 ]; do
    sleep 1
    drain_finished
done

read MIRRORED FAILED < <(collect_results)

echo -e "${GREEN}✓ Mirrored ${MIRRORED} images${NC}"
if [ "${FAILED}" -gt 0 ]; then
    echo -e "${RED}✗ Failed to mirror ${FAILED} images${NC}"
fi
echo ""

if [ "$DRY_RUN" == "true" ]; then
    echo -e "${YELLOW}DRY RUN completed. No images were actually mirrored.${NC}"
    exit 0
fi

if [ $FAILED -gt 0 ]; then
    echo -e "${RED}Error: Some images failed to mirror; not applying ImageContentSourcePolicy.${NC}"
    echo -e "${YELLOW}Fix the failures and re-run, or use --dry-run to verify the plan.${NC}"
    exit 1
fi

# Update cluster mirror configuration
echo -e "${YELLOW}Step 4: Creating mirror configuration (tag + digest)${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# Prefer ImageTagMirrorSet / ImageDigestMirrorSet (OCP 4.12+), keep ICSP for backward compatibility.
cat > /tmp/che-tag-mirrors.yaml <<EOF
apiVersion: config.openshift.io/v1
kind: ImageTagMirrorSet
metadata:
  name: che-tag-mirrors
spec:
  imageTagMirrors:
  - source: quay.io/eclipse
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/eclipse
  - source: quay.io/che-incubator
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/che-incubator
  - source: quay.io/jetstack
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/jetstack
  - source: quay.io/devfile
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/devfile
  - source: quay.io/openshift
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/openshift
  - source: docker.io/library
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/library
  - source: docker.io/alpine
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/alpine
EOF

cat > /tmp/che-digest-mirrors.yaml <<EOF
apiVersion: config.openshift.io/v1
kind: ImageDigestMirrorSet
metadata:
  name: che-digest-mirrors
spec:
  imageDigestMirrors:
  - source: quay.io/eclipse
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/eclipse
  - source: quay.io/che-incubator
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/che-incubator
  - source: quay.io/jetstack
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/jetstack
  - source: quay.io/devfile
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/devfile
  - source: quay.io/openshift
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/openshift
  - source: docker.io/library
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/library
  - source: docker.io/alpine
    mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/alpine
EOF

echo "Created ImageTagMirrorSet: /tmp/che-tag-mirrors.yaml"
echo "Created ImageDigestMirrorSet: /tmp/che-digest-mirrors.yaml"
echo ""

echo -e "${YELLOW}Applying ImageTagMirrorSet / ImageDigestMirrorSet...${NC}"
oc apply -f /tmp/che-tag-mirrors.yaml
oc apply -f /tmp/che-digest-mirrors.yaml
echo -e "${GREEN}✓ Tag/Digest mirror sets applied${NC}"
echo ""

echo -e "${YELLOW}Creating ImageContentSourcePolicy (compat) ...${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

cat > /tmp/che-image-policy.yaml <<EOF
apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: che-images
spec:
  repositoryDigestMirrors:
  # Eclipse Che images
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/eclipse
    source: quay.io/eclipse
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/che-incubator
    source: quay.io/che-incubator

  # Cert-manager images
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/jetstack
    source: quay.io/jetstack
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/openshift
    source: quay.io/openshift
EOF

cat >> /tmp/che-image-policy.yaml <<EOF

  # DevWorkspace images (required for workspace creation + OLM catalogs/bundles)
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/devfile
    source: quay.io/devfile

  # Docker Hub images (required for test infrastructure)
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/library
    source: docker.io/library
  - mirrors:
    - ${LOCAL_REGISTRY}/eclipse-che/alpine
    source: docker.io/alpine
EOF

echo "Created ImageContentSourcePolicy:"
cat /tmp/che-image-policy.yaml
echo ""

echo -e "${YELLOW}Applying ImageContentSourcePolicy...${NC}"
oc apply -f /tmp/che-image-policy.yaml

echo -e "${GREEN}✓ ImageContentSourcePolicy applied${NC}"
echo ""

echo -e "${YELLOW}⚠ WARNING: Nodes will reboot to apply new image policy${NC}"
echo -e "${YELLOW}  This may take 10-15 minutes${NC}"
echo ""

# Monitor node reboots
echo -e "${YELLOW}Step 5: Monitoring node updates${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

echo "Waiting for MachineConfigPool updates..."
echo "You can monitor with: oc get mcp -w"
echo ""

# Display summary
echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${GREEN}║          Image Mirroring Completed Successfully!           ║${NC}"
echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

echo -e "${BLUE}Summary:${NC}"
echo "  Images mirrored:  ${MIRRORED}"
echo "  Failed:           ${FAILED}"
echo "  Registry:         ${LOCAL_REGISTRY}"
echo "  Policy:           che-images"
echo ""

echo -e "${BLUE}Next Steps:${NC}"
echo "  1. Wait for nodes to apply new image policy (10-15 min)"
echo "     Monitor: oc get mcp -w"
echo ""
echo "  2. Verify nodes are Ready:"
echo "     oc get nodes"
echo ""
echo "  3. Deploy Eclipse Che:"
echo "     ./scripts/deploy-che-manual-from-bundles.sh --kubeconfig <kubeconfig> --dashboard-image pr-1442"
echo ""

echo -e "${BLUE}Troubleshooting:${NC}"
echo "  Check mirrored images:"
echo "    oc get imagecontentsourcepolicy che-images"
echo ""
echo "  Verify image policy status:"
echo "    oc get mcp"
echo ""
echo "  Check node status:"
echo "    oc get nodes"
echo ""

echo -e "${GREEN}✓ Image mirroring complete!${NC}"
