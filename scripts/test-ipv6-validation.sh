#!/bin/bash
#
# Copyright (c) 2026 Red Hat, Inc.
# This program and the accompanying materials are made
# available under the terms of the Eclipse Public License 2.0
# which is available at https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Contributors:
#   Red Hat, Inc. - initial API and implementation
#

# IPv6 Test Infrastructure Deployment for Eclipse Che
#
# This script deploys test infrastructure on IPv6-only OpenShift clusters
# to validate Eclipse Che Dashboard PR-1442 IPv6 URL support.
#
# Infrastructure deployed:
# - Devfile HTTP server (serving sample devfiles via IPv6)
# - Git HTTP server (serving test repositories via IPv6)
# - Sample repositories and devfiles
#
# Prerequisites:
# - OpenShift cluster with IPv6 networking
# - oc CLI configured with cluster access
# - Eclipse Che deployed with PR-1442 dashboard
#
# Usage:
#   ./test-ipv6-validation.sh [options]
#
# Options:
#   --kubeconfig <file>   Path to kubeconfig file (uses proxy-url from kubeconfig)
#   --namespace <ns>      Test infrastructure namespace (default: che-test)
#   --che-namespace <ns>  Che namespace (default: eclipse-che)
#   --repo-url <url>      External git repo to mirror and serve over IPv6
#                         Examples:
#                           - git@github.com:che-samples/web-nodejs-sample.git
#                           - https://github.com/che-samples/web-nodejs-sample.git
#   --devfile-url <url>   External devfile URL to mirror and serve over IPv6
#                         Example:
#                           - https://registry.devfile.io/devfiles/nodejs-angular/2.2.1
#   --cleanup            Remove test infrastructure
#   --help               Show this help message
#
# Generated by GPT-5.2

set -euo pipefail

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default configuration
NAMESPACE="che-test"
CHE_NAMESPACE="eclipse-che"
CLEANUP=false
KUBECONFIG_FILE=""
REPO_URL=""
DEVFILE_URL=""
EXTERNAL_DEVFILE_URL=""
EXTERNAL_REPO_URL=""
EXTERNAL_REPO_NAME=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --kubeconfig)
            KUBECONFIG_FILE="$2"
            shift 2
            ;;
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --che-namespace)
            CHE_NAMESPACE="$2"
            shift 2
            ;;
        --repo-url)
            REPO_URL="$2"
            shift 2
            ;;
        --devfile-url)
            DEVFILE_URL="$2"
            shift 2
            ;;
        --cleanup)
            CLEANUP=true
            shift
            ;;
        --help)
            grep '^#' "$0" | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Normalize repo URL (convert common SSH GitHub form to https for cloning inside cluster)
REPO_URL_NORM="${REPO_URL}"
REPO_NAME=""
if [ -n "${REPO_URL_NORM}" ]; then
    if echo "${REPO_URL_NORM}" | grep -q '^git@github.com:'; then
        REPO_URL_NORM="$(echo "${REPO_URL_NORM}" | sed 's|^git@github.com:|https://github.com/|')"
    fi
    REPO_NAME="$(basename "${REPO_URL_NORM}")"
    if ! echo "${REPO_NAME}" | grep -q '\.git$'; then
        REPO_NAME="${REPO_NAME}.git"
    fi
fi

# Set KUBECONFIG if provided
if [ -n "$KUBECONFIG_FILE" ]; then
    if [ ! -f "$KUBECONFIG_FILE" ]; then
        echo -e "${RED}Error: Kubeconfig file not found: $KUBECONFIG_FILE${NC}"
        exit 1
    fi
    export KUBECONFIG="$KUBECONFIG_FILE"
    echo -e "${GREEN}✓ Using kubeconfig: $KUBECONFIG_FILE${NC}"
    echo ""
fi

# Cleanup mode
if [ "$CLEANUP" == "true" ]; then
    echo -e "${YELLOW}Cleaning up test infrastructure...${NC}"
    oc delete namespace ${NAMESPACE} --ignore-not-found=true
    echo -e "${GREEN}✓ Test infrastructure removed${NC}"
    exit 0
fi

echo -e "${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║    Deploying IPv6 Test Infrastructure for Che Dashboard   ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Check prerequisites
echo -e "${YELLOW}Step 1: Checking prerequisites${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

if ! command -v oc &> /dev/null; then
    echo -e "${RED}Error: oc command not found${NC}"
    exit 1
fi
echo -e "${GREEN}✓ oc CLI found${NC}"

if ! oc whoami &> /dev/null; then
    echo -e "${RED}Error: Not logged into OpenShift cluster${NC}"
    exit 1
fi
echo -e "${GREEN}✓ Logged into cluster as $(oc whoami)${NC}"

# Check if cluster has IPv6
SERVICE_NETS_RAW="$(oc get network.config.openshift.io cluster -o jsonpath='{.status.serviceNetwork[*]}' 2>/dev/null || echo "")"
IPV6_SERVICE="$(echo "${SERVICE_NETS_RAW}" | tr ' ' '\n' | grep ':' | head -1 || true)"
if [ -z "$IPV6_SERVICE" ]; then
    echo -e "${YELLOW}⚠ Warning: Cluster may not have IPv6 networking${NC}"
else
    echo -e "${GREEN}✓ Cluster has IPv6 service network: ${IPV6_SERVICE}${NC}"
fi

echo ""

# Create namespace
echo -e "${YELLOW}Step 2: Creating test namespace${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

oc create namespace ${NAMESPACE} --dry-run=client -o yaml | oc apply -f -
echo -e "${GREEN}✓ Namespace ${NAMESPACE} ready${NC}"
echo ""

# Create sample devfiles
echo -e "${YELLOW}Step 3: Creating sample devfiles${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

cat <<'EOF' | oc apply -n ${NAMESPACE} -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: nodejs-devfile
data:
  devfile.yaml: |
    schemaVersion: 2.2.0
    metadata:
      name: nodejs-hello-world
      displayName: Node.js Hello World
      description: Simple Node.js application for testing IPv6
      tags: ["NodeJS", "Express", "IPv6"]
      projectType: "nodejs"
    components:
      - name: nodejs
        container:
          image: registry.access.redhat.com/ubi8/nodejs-18:latest
          memoryLimit: 1024Mi
          mountSources: true
          endpoints:
            - name: http-3000
              targetPort: 3000
    commands:
      - id: install
        exec:
          component: nodejs
          commandLine: npm install
          workingDir: ${PROJECT_SOURCE}
      - id: run
        exec:
          component: nodejs
          commandLine: npm start
          workingDir: ${PROJECT_SOURCE}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: python-devfile
data:
  devfile.yaml: |
    schemaVersion: 2.2.0
    metadata:
      name: python-hello-world
      displayName: Python Hello World
      description: Simple Python application for testing IPv6
      tags: ["Python", "Flask", "IPv6"]
      projectType: "python"
    components:
      - name: python
        container:
          image: registry.access.redhat.com/ubi8/python-39:latest
          memoryLimit: 1024Mi
          mountSources: true
          endpoints:
            - name: http-8080
              targetPort: 8080
    commands:
      - id: install
        exec:
          component: python
          commandLine: pip install -r requirements.txt
          workingDir: ${PROJECT_SOURCE}
      - id: run
        exec:
          component: python
          commandLine: python app.py
          workingDir: ${PROJECT_SOURCE}
EOF

echo -e "${GREEN}✓ Sample devfiles created${NC}"
echo ""

# Create sample repositories
echo -e "${YELLOW}Step 4: Creating sample git repositories${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

cat <<'EOF' | oc apply -n ${NAMESPACE} -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: nodejs-repo
data:
  package.json: |
    {
      "name": "nodejs-hello-world",
      "version": "1.0.0",
      "description": "Simple Node.js app for IPv6 testing",
      "main": "server.js",
      "scripts": {
        "start": "node server.js"
      },
      "dependencies": {
        "express": "^4.18.0"
      }
    }
  server.js: |
    const express = require('express');
    const app = express();
    const port = 3000;

    app.get('/', (req, res) => {
      res.send('Hello from IPv6 Node.js application!');
    });

    app.listen(port, () => {
      console.log(`Server running on port ${port}`);
    });
  README.md: |
    # Node.js Hello World - IPv6 Test

    This is a simple Node.js application for testing Eclipse Che with IPv6.

    ## Run
    ```
    npm install
    npm start
    ```
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: python-repo
data:
  app.py: |
    from flask import Flask
    app = Flask(__name__)

    @app.route('/')
    def hello():
        return 'Hello from IPv6 Python application!'

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080)
  requirements.txt: |
    Flask==3.0.0
  README.md: |
    # Python Hello World - IPv6 Test

    This is a simple Python application for testing Eclipse Che with IPv6.

    ## Run
    ```
    pip install -r requirements.txt
    python app.py
    ```
EOF

echo -e "${GREEN}✓ Sample repositories created${NC}"
echo ""

# Deploy devfile HTTP server
echo -e "${YELLOW}Step 5: Deploying devfile HTTP server${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

cat <<EOF | oc apply -n ${NAMESPACE} -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: devfile-server
  labels:
    app: devfile-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: devfile-server
  template:
    metadata:
      labels:
        app: devfile-server
    spec:
      containers:
      - name: server
        image: docker.io/library/python:3.11-alpine
        env:
        - name: EXTERNAL_DEVFILE_URL
          value: "${DEVFILE_URL}"
        command:
          - sh
          - -c
          - |
            apk add --no-cache curl >/dev/null 2>&1 || true

            # Use /tmp for writable directory (OpenShift security constraints)
            mkdir -p /tmp/devfiles/nodejs /tmp/devfiles/python /tmp/devfiles/external

            # Copy devfiles from ConfigMaps
            cp /config/nodejs/devfile.yaml /tmp/devfiles/nodejs/devfile.yaml
            cp /config/python/devfile.yaml /tmp/devfiles/python/devfile.yaml

            # Optionally fetch and mirror an external devfile
            if [ -n "${EXTERNAL_DEVFILE_URL:-}" ]; then
              echo "Fetching external devfile: ${EXTERNAL_DEVFILE_URL}"
              if curl -fsSL "${EXTERNAL_DEVFILE_URL}" -o /tmp/devfiles/external/devfile.yaml; then
                echo "✓ External devfile mirrored"
              else
                echo "⚠ Could not fetch external devfile (will keep sample devfiles only)"
              fi
            fi

            # Create index.json (include external devfile if present)
            python3 - <<'PY'
            import json, os
            items = [
              {
                "name": "nodejs-hello-world",
                "displayName": "Node.js Hello World",
                "description": "Simple Node.js application for IPv6 testing",
                "type": "stack",
                "tags": ["NodeJS", "Express", "IPv6"],
                "url": "/nodejs/devfile.yaml",
              },
              {
                "name": "python-hello-world",
                "displayName": "Python Hello World",
                "description": "Simple Python application for IPv6 testing",
                "type": "stack",
                "tags": ["Python", "Flask", "IPv6"],
                "url": "/python/devfile.yaml",
              },
            ]
            if os.path.exists("/tmp/devfiles/external/devfile.yaml"):
              items.append({
                "name": "external-devfile",
                "displayName": "External Devfile (mirrored)",
                "description": "Devfile fetched from EXTERNAL_DEVFILE_URL and served over IPv6",
                "type": "stack",
                "tags": ["External", "IPv6"],
                "url": "/external/devfile.yaml",
              })
            with open("/tmp/devfiles/index.json", "w") as f:
              json.dump(items, f, indent=2)
            PY

            # Start HTTP server on all interfaces (:: for IPv4 and IPv6)
            cd /tmp/devfiles
            echo "Starting devfile HTTP server on port 8080..."
            python3 -m http.server 8080 --bind ::
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        volumeMounts:
        - name: nodejs-devfile
          mountPath: /config/nodejs
        - name: python-devfile
          mountPath: /config/python
        resources:
          limits:
            memory: 128Mi
          requests:
            memory: 64Mi
      volumes:
      - name: nodejs-devfile
        configMap:
          name: nodejs-devfile
      - name: python-devfile
        configMap:
          name: python-devfile
---
apiVersion: v1
kind: Service
metadata:
  name: devfile-server
  labels:
    app: devfile-server
spec:
  type: ClusterIP
  ipFamilyPolicy: SingleStack
  ipFamilies:
    - IPv6
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: devfile-server
EOF

echo -e "${GREEN}✓ Devfile server deployed${NC}"
echo ""

# Deploy git HTTP server
echo -e "${YELLOW}Step 6: Deploying git HTTP server${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

cat <<EOF | oc apply -n ${NAMESPACE} -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: git-server
  labels:
    app: git-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: git-server
  template:
    metadata:
      labels:
        app: git-server
    spec:
      containers:
      - name: server
        image: alpine/git:latest
        env:
        - name: EXTERNAL_REPO_URL
          value: "${REPO_URL_NORM}"
        - name: EXTERNAL_REPO_NAME
          value: "${REPO_NAME}"
        command:
          - sh
          - -c
          - |
            # Install lighttpd for HTTP server
            apk add --no-cache lighttpd ca-certificates >/dev/null 2>&1 || true

            # Use /tmp for writable directory (OpenShift security constraints)
            mkdir -p /tmp/repos/nodejs-hello-world.git
            mkdir -p /tmp/repos/python-hello-world.git
            mkdir -p /tmp/repos/testuser/nodejs-hello-world.git
            mkdir -p /tmp/repos/testuser/python-hello-world.git
            mkdir -p /tmp/cgi-bin

            # Initialize nodejs repository (.git suffix for direct git access)
            cd /tmp/repos/nodejs-hello-world.git
            git init --bare
            git config --local http.receivepack true
            git config --local http.uploadpack true

            # Create working copy and commit files
            TEMP_DIR=\$(mktemp -d)
            cd \$TEMP_DIR
            git init
            cp /config/nodejs/* .
            git add .
            git commit -m "Initial commit"
            git push file:///tmp/repos/nodejs-hello-world.git master
            cd /tmp

            # Initialize python repository (.git suffix for direct git access)
            cd /tmp/repos/python-hello-world.git
            git init --bare
            git config --local http.receivepack true
            git config --local http.uploadpack true

            # Create working copy and commit files
            TEMP_DIR=\$(mktemp -d)
            cd \$TEMP_DIR
            git init
            cp /config/python/* .
            git add .
            git commit -m "Initial commit"
            git push file:///tmp/repos/python-hello-world.git master
            cd /tmp

            # Create GitHub-style repositories (user/repo format)
            # These are clones of the .git repos but accessible via GitHub-style URLs
            cd /tmp/repos/testuser/nodejs-hello-world.git
            git init --bare
            git config --local http.receivepack true
            git config --local http.uploadpack true
            git --git-dir=/tmp/repos/nodejs-hello-world.git push --mirror file:///tmp/repos/testuser/nodejs-hello-world.git

            cd /tmp/repos/testuser/python-hello-world.git
            git init --bare
            git config --local http.receivepack true
            git config --local http.uploadpack true
            git --git-dir=/tmp/repos/python-hello-world.git push --mirror file:///tmp/repos/testuser/python-hello-world.git

            # Update git server info for all repos
            cd /tmp/repos/nodejs-hello-world.git && git update-server-info
            cd /tmp/repos/python-hello-world.git && git update-server-info
            cd /tmp/repos/testuser/nodejs-hello-world.git && git update-server-info
            cd /tmp/repos/testuser/python-hello-world.git && git update-server-info

            # Create GitHub API mock endpoint
            cat > /tmp/cgi-bin/github-api.sh <<'API_SCRIPT'
#!/bin/sh
# Simple GitHub API mock for testing IPv6 URL recognition
echo "Content-Type: application/json"
echo "Status: 200 OK"
echo ""
echo '{"id":1,"name":"test-repo","full_name":"testuser/test-repo","private":false,"owner":{"login":"testuser","id":1},"html_url":"http://localhost/testuser/test-repo","description":"Test repository","fork":false,"default_branch":"master"}'
API_SCRIPT
            chmod +x /tmp/cgi-bin/github-api.sh

            # Optionally mirror an external repository (best effort)
            if [ -n "${EXTERNAL_REPO_URL:-}" ] && [ -n "${EXTERNAL_REPO_NAME:-}" ]; then
              echo "Mirroring external repo: ${EXTERNAL_REPO_URL}"
              if git clone --mirror "${EXTERNAL_REPO_URL}" "/tmp/repos/${EXTERNAL_REPO_NAME}"; then
                git -C "/tmp/repos/${EXTERNAL_REPO_NAME}" config --local http.receivepack true
                git -C "/tmp/repos/${EXTERNAL_REPO_NAME}" config --local http.uploadpack true
                git -C "/tmp/repos/${EXTERNAL_REPO_NAME}" update-server-info || true
                echo "✓ External repo mirrored to /${EXTERNAL_REPO_NAME}"
              else
                echo "⚠ Could not mirror external repo (will keep sample repos only)"
              fi
            fi

            # Configure lighttpd
            cat > /tmp/lighttpd.conf <<'LIGHTTPD'
            server.modules = (
                "mod_access",
                "mod_alias",
                "mod_cgi",
                "mod_setenv",
                "mod_redirect",
                "mod_rewrite"
            )

            server.document-root = "/tmp/repos"
            server.port = 8080
            server.bind = "::"

            mimetype.assign = (
                ".git" => "application/x-git",
                ".json" => "application/json"
            )

            # GitHub API endpoints
            \$HTTP["url"] =~ "^/api/v3/" {
                cgi.assign = ( "" => "/tmp/cgi-bin/github-api.sh" )
            }

            # GitHub-style URLs: /user/repo -> /user/repo.git (git HTTP backend)
            \$HTTP["url"] =~ "^/[^/]+/[^/]+/info/refs" {
                url.rewrite-once = ( "^/([^/]+)/([^/]+)/(.*)$" => "/\$1/\$2.git/\$3" )
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }

            \$HTTP["url"] =~ "^/[^/]+/[^/]+/git-upload-pack" {
                url.rewrite-once = ( "^/([^/]+)/([^/]+)/(.*)$" => "/\$1/\$2.git/\$3" )
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }

            \$HTTP["url"] =~ "^/[^/]+/[^/]+/git-receive-pack" {
                url.rewrite-once = ( "^/([^/]+)/([^/]+)/(.*)$" => "/\$1/\$2.git/\$3" )
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }

            # Standard .git repositories
            \$HTTP["url"] =~ "^/[^/]+\.git/git-upload-pack" {
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }

            \$HTTP["url"] =~ "^/[^/]+\.git/git-receive-pack" {
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }

            \$HTTP["url"] =~ "^/[^/]+\.git/info/refs" {
                cgi.assign = ( "" => "/usr/libexec/git-core/git-http-backend" )
                setenv.add-environment = (
                    "GIT_PROJECT_ROOT" => "/tmp/repos",
                    "GIT_HTTP_EXPORT_ALL" => "1"
                )
            }
            LIGHTTPD

            # Start lighttpd
            echo "Starting git HTTP server on port 8080..."
            lighttpd -D -f /tmp/lighttpd.conf
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        volumeMounts:
        - name: nodejs-repo
          mountPath: /config/nodejs
        - name: python-repo
          mountPath: /config/python
        resources:
          limits:
            memory: 256Mi
          requests:
            memory: 128Mi
      volumes:
      - name: nodejs-repo
        configMap:
          name: nodejs-repo
      - name: python-repo
        configMap:
          name: python-repo
---
apiVersion: v1
kind: Service
metadata:
  name: git-server
  labels:
    app: git-server
spec:
  type: ClusterIP
  ipFamilyPolicy: SingleStack
  ipFamilies:
    - IPv6
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: git-server
EOF

echo -e "${GREEN}✓ Git server deployed${NC}"
echo ""

# Wait for deployments
echo -e "${YELLOW}Step 7: Waiting for services to be ready${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

echo "Waiting for devfile-server..."
oc rollout status deployment/devfile-server -n ${NAMESPACE} --timeout=120s
echo -e "${GREEN}✓ Devfile server ready${NC}"

echo "Waiting for git-server..."
oc rollout status deployment/git-server -n ${NAMESPACE} --timeout=120s
echo -e "${GREEN}✓ Git server ready${NC}"

echo ""

# Get service IPs
echo -e "${YELLOW}Step 8: Retrieving service information${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

DEVFILE_IPV6=$(oc get service devfile-server -n ${NAMESPACE} -o jsonpath='{.spec.clusterIPs[0]}')
DEVFILE_IPV4=$(oc get service devfile-server -n ${NAMESPACE} -o jsonpath='{.spec.clusterIPs[1]}' 2>/dev/null || echo "N/A")
GIT_IPV6=$(oc get service git-server -n ${NAMESPACE} -o jsonpath='{.spec.clusterIPs[0]}')
GIT_IPV4=$(oc get service git-server -n ${NAMESPACE} -o jsonpath='{.spec.clusterIPs[1]}' 2>/dev/null || echo "N/A")

echo -e "${BLUE}Service Information:${NC}"
echo ""
echo "Devfile Server:"
echo "  IPv6 Address: ${DEVFILE_IPV6}"
echo "  IPv4 Address: ${DEVFILE_IPV4}"
echo "  Service Name: devfile-server.${NAMESPACE}.svc.cluster.local"
echo ""
echo "Git Server:"
echo "  IPv6 Address: ${GIT_IPV6}"
echo "  IPv4 Address: ${GIT_IPV4}"
echo "  Service Name: git-server.${NAMESPACE}.svc.cluster.local"
echo ""

# Test URLs
echo -e "${YELLOW}Step 9: Testing service accessibility${NC}"
echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"

# Test devfile server
echo "Testing devfile server..."
TEST_POD=$(oc run test-curl --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -s "http://[${DEVFILE_IPV6}]:8080/index.json" 2>&1 || echo "")
if echo "$TEST_POD" | grep -q "nodejs-hello-world"; then
    echo -e "${GREEN}✓ Devfile server responding on IPv6${NC}"
else
    echo -e "${YELLOW}⚠ Could not verify devfile server on IPv6${NC}"
fi

# Test git server
echo "Testing git server..."
TEST_POD=$(oc run test-curl --image=curlimages/curl:latest --rm -i --restart=Never -n ${NAMESPACE} -- curl -s "http://[${GIT_IPV6}]:8080/nodejs-hello-world.git/info/refs?service=git-upload-pack" 2>&1 || echo "")
if echo "$TEST_POD" | grep -q "git-upload-pack"; then
    echo -e "${GREEN}✓ Git server responding on IPv6${NC}"
else
    echo -e "${YELLOW}⚠ Could not verify git server on IPv6${NC}"
fi

echo ""

# Display test URLs
echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
echo -e "${GREEN}║     Test Infrastructure Deployed Successfully!             ║${NC}"
echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
echo ""

echo -e "${BLUE}IPv6 Test URLs for Eclipse Che:${NC}"
echo ""
echo "Devfile Server (IPv6):"
echo "  Index:         http://[${DEVFILE_IPV6}]:8080/index.json"
echo "  Node.js:       http://[${DEVFILE_IPV6}]:8080/nodejs/devfile.yaml"
echo "  Python:        http://[${DEVFILE_IPV6}]:8080/python/devfile.yaml"
echo ""
echo "Git Server (IPv6):"
echo "  Node.js repo:  http://[${GIT_IPV6}]:8080/nodejs-hello-world.git"
echo "  Python repo:   http://[${GIT_IPV6}]:8080/python-hello-world.git"
echo ""
echo "GitHub-style URLs (IPv6) - for testing GitHub URL parser:"
echo "  Node.js repo:  http://[${GIT_IPV6}]:8080/testuser/nodejs-hello-world"
echo "  Python repo:   http://[${GIT_IPV6}]:8080/testuser/python-hello-world"
echo "  GitHub API:    http://[${GIT_IPV6}]:8080/api/v3/user"
echo ""

if [ -n "${REPO_NAME}" ]; then
    echo "External inputs:"
    echo "  repo-url:     ${REPO_URL}"
    echo "  repo-url (normalized for cloning): ${REPO_URL_NORM}"
    if [ -n "${DEVFILE_URL}" ]; then
        echo "  devfile-url:  ${DEVFILE_URL}"
    else
        echo "  devfile-url:  (not provided)"
    fi
    echo ""
    echo "External repo (mirrored, via IPv6):"
    echo "  http://[${GIT_IPV6}]:8080/${REPO_NAME}"
    if [ -n "${DEVFILE_URL}" ]; then
        echo "  with devfile (mirrored): http://[${GIT_IPV6}]:8080/${REPO_NAME}?df=http://[${DEVFILE_IPV6}]:8080/external/devfile.yaml"
    fi
    echo ""
fi

echo -e "${BLUE}Testing IPv6 URL Support in Che Dashboard:${NC}"
echo ""
echo "IMPORTANT: The cluster proxy does NOT support IPv6 URLs directly in browser."
echo "Use the Che Dashboard API instead:"
echo ""
echo "1. Get Che URL:"
echo "   CHE_URL=\$(oc get checluster eclipse-che -n ${CHE_NAMESPACE} -o jsonpath='{.status.cheURL}')"
echo "   echo \$CHE_URL"
echo ""
echo "2. Launch Chrome with proxy:"
echo "   # macOS"
echo "   killall \"Google Chrome\" 2>/dev/null"
echo "   /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome \\"
echo "     --proxy-server=\"\$(grep proxy-url \$KUBECONFIG | awk '{print \$2}')\" \\"
echo "     --user-data-dir=\"/tmp/chrome-che-proxy-\$(date +%s)\" \\"
echo "     --no-first-run \\"
echo "     \"\${CHE_URL}/dashboard/api/swagger/static/index.html\""
echo ""
echo "3. Test IPv6 URLs via Swagger API (POST /dashboard/api/data/resolver):"
echo ""
echo "   Test devfile index:"
echo "   {\"url\": \"http://[${DEVFILE_IPV6}]:8080/index.json\"}"
echo ""
echo "   Test Node.js devfile:"
echo "   {\"url\": \"http://[${DEVFILE_IPV6}]:8080/nodejs/devfile.yaml\"}"
echo ""
echo "   Test Python devfile:"
echo "   {\"url\": \"http://[${DEVFILE_IPV6}]:8080/python/devfile.yaml\"}"
echo ""
echo "   Test GitHub-style URL (tests GitHub URL parser with IPv6):"
echo "   {\"url\": \"http://[${GIT_IPV6}]:8080/testuser/nodejs-hello-world\"}"
echo ""
echo "4. Expected result: HTTP 200 with devfile content (confirms IPv6 URL support works)"
echo ""

echo -e "${BLUE}Cleanup:${NC}"
echo "  ./test-ipv6-validation.sh --cleanup"
echo ""

echo -e "${GREEN}✓ Ready for IPv6 testing!${NC}"
